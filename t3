


 
  
  1) 구조체


  1.    C언어에서 함수 선언은 main() 보다 앞에 호출되어야.


  2.    C++에서 함수는 구조체 안에 작성할 수 있다. (멤버함수)


  3.    C++에는 전역함수와 ‘지역함수’가 있다. 구조체 안에 선언된 멤버함수를 ‘지역함수’라고 한다. à ‘객체’에 의해서 호출됨


  4.    Const 함수를 이용하면 읽기만 가능한 함수를 만들 수 있다.


  5.    private: 권한을 통해 struct 외부에서의 접근을 막는다.


  2) 기본 입출력


  1.    cout: <<연산자 이용해서 출력


  2.    cin: >>연산자 이용해서 입력


  3.    #include <iostream>, using namespace
  std; 이용


  4.    cout<<hex<<10,
  cout<<oct<<10, cout<<dec<<10. 각각 16진수,
  8진수, 10진수로 출력.


  5.    cout<<10 은 마지막에 입력된 진수값으로 출력 (기본)


  6.    여백문자를 입력받을 땐, cin.getline(char*
  addr, int len) 을 사용하자.


  7.    cin.ignore() 함수는 ‘\n’ 엔터를 무시해준다.


  (cin은 기본적으로 엔터를 같이 입력받는다.)


  8.    for(int n : array){ } 는 배열의 크기를 몰라도 배열을 순회.


  9.    Scope연산자(::)를 사용해 구조체 안에는 멤버함수의 선언부만 넣어서 단순화하고 구조체 밖으로
  빼서 구조체 소속을 명확하한 함수를 작성한다.


  Ex)  void st:: PrintStruct(void) { }


  10.  C++는 전역변수와 지역변수가 있으면, (::)연산자로 전역변수에 우선적으로 접근할 수 있다. 


  형식: ( :: 변수명 )


  11.  완벽한 OOP라면 전역변수는 없어야 정상. 하지만 C++는 완벽한 OOP가
  아니라서 전역에 조금 의존적이다. 


  è  전역을 쓰는 걸 명확히 하기 위해서 (::) 연산자를
  쓰자.


  3) Const 포인터


  12.  const int* 라는 타입은 ‘읽기만 할 것’ 이라는 것이다.


  13.  C++은 C보다 상수화 const가 더 견고하다. 


  14.  const int * q는 초기값이 필요 없지만, int * const p 는
  초기값이 필요하다. q는 포인터이기 때문에 상수화된 값을 가리키는 역할. p는 주소라서 상수값이 주어져야 함.


  4) 함수의 중복


  1.    함수명이 같더라도 인자의 개수, 인자의 타입이 다르면
  중복정의 가능.


  2.    중복정의가 불가능한 경우:


  a)    리턴타입이 다른 경우


  b)    reference 인수타입과 value 인수타입 


  (중복정의 가능하지만 모호한 호출 오류)


  c)     디폴트 파라미터로 중복정의 된 함수 


  (중복정의 가능하지만 모호한 호출 오류)


  d)    포인터 인수타입과 배열 인수타입의 함수


  e)    const가 있는 value 인수타입과  일반 value 인수타입


  3.    Call Protocol (__cdecl): caller와 callee가 데이터를 주고받는 방식을 정의. 예를 들어 Stack Cleanup을 어디에서 할 것인지? C언어는 함수를 호출하는 caller에서 청소해준다. à 콜할 때마다 클린업 코드가 쌓임.


  Call
  Protocol 에 의하면 함수명은 ‘_’ 로 시작해야 한다.


  4.    C언어로 작성하면 코드가 너무 길어지는 문제를 해결하기 위해 마이크로소프트는 Pascal이라는
  데이터 통신 규약을 채택함.


  5) 디폴트 파라미터


  1.    함수 호출시 부족한 인자를 대신 채워주는 값


  함수 선언 시에 미리 정의되어
  있어야 함.


  2.    디폴트 파라미터는 함수 선언할 때 제일 우측 파라미터부터
  정의 가능.


  6) 레퍼런스(Reference) //참조형


  1.    기억공간에 다른 이름을 붙이는 것


  2.    Call By Reference: 레퍼런스를 함수의 인수 전달에 적용한 것


  3.    포인터처럼 쓸 수 있음.


  4.    참조형 함수를 호출해서 나온 리턴값에 다른 값을 저장하면 그 참조형 함수 안에 static 변수의 값이 바뀐다!


  5.    이렇듯 참조형은 포인터처럼 쓸 수 있다. 하지만
  참조형은 따로 객체를 만드는 것이 아니라 ‘별명’을 만드는
  것임!


  6.    Const 참조형도 가능.


  7) inline 함수


  1.    인라인 함수는 함수 정의부가 컴파일 시간에 함수의 호출 위치에 인라인 확장됨.


  2.    예약어 ‘inline’으로 선언 및 정의되는 함수.


  3.    호출 위치보다 먼저 정의되어있어야 하고, 일반적으로
  헤더파일에 선언.


  8) 입력오류
  처리


  1.    cin.ignore() 함수는 cin개체의 멤버데이터 state가 0으로 되어 있는지 물어 그렇다면 버퍼를 비웁니다.


  2.    cin.clear(); // cin 개체의 멤버데이터 state(오류 상태 비트 필드)를 0으로 clear합니다. 


  // cin.rdbuf() : 입력버퍼를 담당하는 개체 포인터(streambuf *)를 리턴합니다. 


  //
  in_avail() : streambuf클래스의
  멤버함수로 버퍼에 남아있는 문자 갯수를 리턴합니다.


  9) 동적 메모리
  할당과 연산자


  1.    C언어에서 free(p); 주의해서 사용할 부분은
  p++; 같은 연산을 하면 p가 가리키는 주소가 바뀌기 때문에 기존에 할당된 동적메모리
  삭제가 안된다


  2.    C++에서는 new 는 malloc()의 역할. delete 는 free()함수의 역할을 함.


  3.    char* str = new char[len];  delete [] str;


  4.    char** str; 


  for(~n)
  str[n] = new char[len];  for(~n) delete
  [] str[n];


  10) enum형


  1.    예약어. 순차적인 정수형 상수를 만들 때 사용.


  enum
  열거형이름 {상수1, 상수2, 상수3, …};


  2.    크기는 int형


  3.    C언어에서는 enum형으로 선언된 변수에 어떠한 정수값도 대입이 가능했는데, C++에서는 반드시 enum형으로 만들어진 상수만 대입이 가능합니다.


  
 
 
  
  1) 리뷰


  1.     구조체와 클래스의 차이: 거의 비슷한데, 구조체의 default 권한은
  public, 클래스의 default 권한은
  private.


  2) 이름없는
  공용체


  1.     전역으로 이름없는 공용체를 선언하려면 ‘static’을
  꼭 붙여야 함. (C++)


  2.     공용체 안에 이름없는 구조체를 쓸 수 있음.


  3) 공간이름 (namespace)와 using 예약어


  1.     namespace A { } // namespace B { } 이런 식으로 구분


  2.     여러 개의 파일에 존재하는 전역변수의 중복을 방지하기 위해 사용합니다.


  4) 클래스


  1.     클래스는 개체를 만들어 내는 틀로써 C++의 구조체처럼
  형틀을 정의하고 개체를 생성할 수 있습니다. 형틀 정의 시 예약어
  'class'를 사용합니다.


  2.     Default 접근권한은 private. 


  5) 생성자 함수


  1.     클래스 이름과 동일한 이름의 멤버함수로 개체 초기화를 담당하는 멤버함수.


  2.     클래스에서 가장 먼저 호출하는 멤버함수 (모든 object는 단 한번만 생성자함수를 호출함)


  3.     Return type을 명시할 수 없음. (생성자, 소멸자, 형변환 연산) //return 값이 없기 때문.


  4.     Default 생성자함수: 클래스에 생성자함수를 만들지 않으면 컴파일러에 의해 빈문장의 생성자함수가
  자동으로 만들어짐.


  5.     오버로딩으로 중복정의 가능.


  6.     friend, static, const, virtual 함수 불가능.


  7.     기본 생성자 A(){}는 컴파일러가 제공하지만, 생성자와 인자를 정의하면 컴파일러는 이제 기본 생성자를 제공하지 않음. à습관적으로 기본생성자를 만들자.


  8.     기본 생성자는 A aa; 로 선언한다 A aa(); 로 선언하면 함수를 부르기 때문에 안됨.


  9.     가장 잘 설계된 class는 int type을 담는 클래스. 왜냐하면 int type을 중심으로 만들어진 함수, 알고리즘 등 데이터베이스를
  그대로 활용할 수 있기 때문.


  10.  A aa[2]; //
  A 객체를 기본생성자로 2개 만듬.


  A
  aa[ ] = { A( ), A(5), A(5, 'A') };    //여러 생성자 호출 가능


  A
  bb[ ] ={ { }, { 5 }, { 5, 'A' } };         //중괄호 초기화 가능


  A *
  ap[] ={new A, new A(5), new A(5,'A'), new A[2]};


  // 생성자 포인터로도 선언 가능.


  for (int n = 0; n<3; n++) delete ap[n];        // (1)


  delete[]
  ap[3];     // (2) 둘 다 가능.


  6) 소멸자


  1.     소멸자도 클래스 이름과 동일하지만 생성자와 구별하기 위해 앞에 ‘~’ 를 붙인 이름의 멤버함수.


  2.     컴파일러는 끝날 때 자동으로 aa.~A(); 같은
  소멸자 함수를 불러옴. 파라미터를 전달할 수 없음.


  3.     따라서 우리는 소멸자 코드 안에 마무리 작업을 넣어주면 됨.
  (delete 이름 을 넣어주자)


  4.     friend, static 멤버 함수로 둘 수 없음.


  5.     소멸자함수는 virtual 함수로 두는 것이 일반적 (상속관계시)


  6.     상속 관계에서 소멸자함수의 수행 순서는 생성자함수 수행의 역순


  7.     A* p = new A[3];


  delete[
  ] p;  //소멸자 안에 설계해서 호출해올 수도 있음.


  이 경우에는 소멸자를 각 배열
  차례대로 실행시켜주기 위해서, 무조건 delete [ ] 로
  지워줘야 함. 


  8.     디폴트 소멸자 함수로는 자동으로 삭제되지 않기 때문에 직접 delete로
  지워주거나 직접 소멸자 안에 설계해줘야 함. 소멸자는 단순히 컴파일러 마지막에 호출될 뿐.


  9.     기본
  소멸자를 만들면 현재 포인터에서 4byte전 주소에 연속된 원소의 갯수를 표기하고, 그 지점에서 16byte전 주소( 즉, 포인터 p위치에서 20바이트 전 주소 )에 메모리 해제의 크기를 명시해 놓는다.


  10.  기본
  소멸자가 없다면 현재 포인터p에서 16바이트 전 주소에
  메모리 해제의 크기를 명시한다.


  7) 예약어 this


  1.     예약어 this 는 멤버 함수 내에서만 사용할 수
  있고, 그 멤버 함수를 호출한 객체의 주소를 가리킴(포인터
  상수).


  2.     전역함수 및 friend 함수, static 함수에서 쓸 수 없음.


  3.     void __thiscall A::sub(int dummy)


  è  __thiscall 이 생략되어 있는 것.


  è  예약어 this의 사용이 가능한 것은 멤버함수가 __thiscall 호출 규약을 사용하기 때문이며, 예외적으로 _cdecl호출 규약을 사용하는 멤버함수도 this를 사용할 수
  있습니다.


  4.     참조형으로 *this를 리턴하면 객체는 생성되지
  않는다.


  8) Embedded Object (포함된 개체)


  1.     클래스 안에 클래스 라는 뜻. 클래스의 멤버데이터
  중 기존하는 클래스로 선언된 개체가 있을 경우, 이 개체를 포함된 개체(Embedded object)라고 합니다. 


  2.     콜론(:) 초기화의 종류


  a)    - 묵시적 콜론 초기화 : 컴파일러에 의한 초기화(컴파일러에
  의해 생성자함수 호출 코드가 자동으로 삽입) 


  b)    - 명시적 콜론 초기화 : 사용자가 콜론(:)을
  사용하여 적절한 초기화를 명시적으로 표현하는 것


  3.     최근 컴파일러에서는 클래스 설계 내부의 변수에 값을 지정할 수 있음. (원래 클래스는 공간이 주어지지 않고 객체를 생성했을 때 실제로 공간이 생성됨에도 불구)


  9) Const 멤버 함수


  1.     예약어 const로 선언 및 정의되는 멤버함수.


  2.     생성자, 소멸자 함수는 const 멤버함수로 둘 수 없음.


  3.     예시) void sub(void) const;  // 리턴이 const인
  경우와 구별하기 위해 뒤에 const를 붙임.


  4.     const 멤버함수의 멤버데이터는 읽기 전용이지만, 예외적으로
  mutable로 선언된 멤버데이터는 변경 가능.


  5.     const 
  멤버함수 안에서 this->func() 과 같이 const가 아닌 멤버함수는
  호출할 수 없다. func()에서 멤버변수를 바꿀 수도 있기 때문.


  6.     func() 도 역시 const  라면 this->func() 으로 호출 가능. 왜냐하면 여기서
  ‘this’ 의 타입은 ‘const 클래스 포인터’ 이기 때문


  7.     const와 const 아닌 함수 사이 중복정의도 가능.


  8.     const 멤버함수에서의 리턴 시 주의사항


  a)     - const 멤버함수에서 호출한 개체의 포인터 또는 
  참조형으로 리턴하는 경우 반드시 const형 리턴이어야 함.


  b)     - const 멤버함수에서 멤버데이터의 포인터 또는 참조형으로 리턴하는 경우 반드시 const형 리턴이어야
  함.


   


  10) Const 개체


  1.     const 개체는 오로지 const 멤버함수만을 호출 할 수 있습니다.(일반 멤버함수 호출 시 멤버데이터의 값이 변경될 수 있으므로)


  11) static 멤버데이터


  1.     클래스 안에서 선언(멤버데이터이므로)하고 외부에서 정의(전역변수의 스코프 때문에) 및 초기화 (초기화시에는
  private, public 가리지 않음)


  2.     생성자함수 안에서 값의 대입은 가능하지만 콜론초기화는 할 수 없음. 


  3.     static 멤버데이터는 단 한 개만 만들어지고 모든 개체가 공유!! (같은 클래스를 베이스로 하는
  객체가 여러 개라도 static 멤버데이터는 단 하나만 존재한다는 것이 중요)


  4.     스코프 연산자( :: )로 접근 권장.


  12) static 멤버함수


  1.     전역함수처럼 개체 없이 호출 가능한 멤버함수 (개체를
  통해서도 호출 가능)


  2.     __thiscall 호출규약을 사용하지 않기 때문에 예약어 'this'를 사용할 수 없습니다.


  3.     Static 멤버함수에서는 일반 멤버변수, 멤버함수에는 접근 불가.


  4.     Static 멤버함수에서 static 멤버변수, 멤버함수는
  호출가능.


  5.     Static 멤버함수는 const 불가.


   


  
 
 
  
  1) friend 함수


  1.     클래스 안에 선언되는 함수이지만 멤버함수는 아님.


  2.     클래스의 모든 멤버데이터(private 멤버까지도)를 접근가능


  3.     멤버함수가 아니기 때문에 상속되지 않음.


  4.     Private 권한에 접근하는 용도로 쓰는 것이 아님.


  5.     해당 클래스와 관련있는 ‘친구’함수라는 것을 표현하는 용도.


  2) friend 클래스


  1.     friend로 선언된 클래스의 모든 멤버함수는 선언한 클래스의 모든 멤버를 접근할 수 있게 됨.


  2.     자주 사용하진 않음.


  3) 연산자 중복 (오퍼레이터 오버로딩)


  1.     기존 연산자의 기능(상수와 변수에 대한 연산)을 개체까지도 연산이 가능하도록 연산자의 기능을 확장시키는 것


  2.     기존 연산자 중 .  .* 
  ::  ?:  sizeof 연산자는 중복 정의할 수 없음.


  4) Default 대입 연산자함수와 대입 연산자함수 중복


  1.     클래스 안에 대입 연산자함수를 정의하지 않으면 자동으로 대입 연산자함수가 정의됨.


  2.     Default 대입 연산자함수는 멤버데이터 대 멤버데이터를 대입하는 형태


  3.     포인터 멤버데이터에 동적 메모리가 할당될 경우 메모리가 공유되는 문제를 유발


  4.     String 타입을 넣을 때는 <string.h> 에 포함된 strlen( )으로 길이 계산하고 넣어줘야 함.


  5.     대입 연산자함수 중복 정의 시 고려할 사항 


  a)     - 기존하는 메모리가 있다면 제거하기


  b)     - 자기 자신을 대입하는지 조사하기


  c)     - 다중 대입을 지원하기 위해 자기 자신 되돌리기


  5) 복사 생성자함수 (Copy Constructor)


  1.     클래스 자기 자신의 참조형으로 인수를 전달받는 생성자함수


  2.     Default 복사 생성자함수는 멤버데이터 대 멤버데이터를 대입하는 형태로 만들어짐


  3.     동적 메모리에 할당된 경우, 메모리를 공유하는 형태로
  만들어지기 때문에 수정해야.


  4.     대입연산자 함수는 이미 만들어진 개체가 호출하는 반면 복사 생성자함수는 새로 만들어지는 개체가
  호출


  5.     자기 자신을 조사할 필요 없음. 생성자함수이므로
  리턴값이 있을 수 없음.


  6) R-Value 참조


  1.     상수 또는 임시기억공간에 대한 참조


  2.     형식:   자료형 && 별명 = 상수


  3.     const형 참조와 달리 값을 변경할 수 있음.


  7) 이동 생성자함수(Move Constructor) 


  1.     형식:


  클래스명::클래스명(클래스명 && 변수명)


  {


  }


  2.     복사 생성자함수보다 이동 생성자함수의 호출이 우선


  3.     RVO(Return Value Optimization) : 이름없는 개체 리턴 시 임시개체를 생성하지 않는 최적화


  4.     NRVO(Named Return Value Optimization)


  a)      개체 이름으로 리턴 시 임시개체를 생성하지 않는 최적화


  b)      2013 미지원, 2015 컴파일러 옵션으로 지원


  5.     이동 생성자를 이용하면 R-Value를 참조할 수
  있기 때문에 더 저비용의 코드를 만들 수 있다.


  8) 형변환 연산자
  함수


  1.     멤버함수로만 정의 할 수 있으며 단항 연산자이므로 인수전달이 없음.


  2.     리턴값을 갖지만 리턴타입을 명시할 수 없음.


  3.     형식:


  클래스명::operator 자료형(void)


  {


  }


  4.     여러 개의 형변환 연산자함수를 둘 경우,  적절한 형변환 연산자 함수 호출을 위해 명시적 형변환이 요구됨.


  5.     묵시적 형변환 시 우선 호출되는 형변환 연산자 함수 


  a)     - ⓐ Int, double, float 모두 정의된 경우 모호한 호출 오류 발생합니다.


  b)     - ⓑ const char *와 char * 중 const char *가 우선 호출되며 ⓐ 함수가 우선합니다.


  c)       ⓒ char는 ⓑ 함수와는 모호한 호출 오류가 발생하고
  ⓐ 함수가 우선합니다.


  9) 배열 연산자
  함수(operator [])


  1.     멤버함수로만 정의 가능.


  2.     함수형식:


  리턴형 클래스명::operator[](int n)


  {


  }


  10) 포인터 연산자
  함수(operator *)


  1.     멤버함수로만 정의 가능


  2.     함수형식:


  리턴형 클래스명::operator *(void)


  {


  }


  
 
 
  
  1) 상속(Inheritance)


  1.     물려주는 기존하는 클래스를 기반(base)클래스라
  하고, 물려받는 새로운 클래스를 파생(Derived)클래스


  2.     기반 클래스의 모든 멤버는 상속되지만, 기반 클래스의 private 멤버는 파생 클래스에서 접근 불가.


  3.     기반 클래스의 protected 권한 멤버는 파생
  클래스에서 public 멤버로 중복정의해서 접근할 수 있음.


  4.     마찬가지로 기반 클래스의 public 멤버도 파생
  클래스의 private 멤버로 중복정의하면, 접근 불가능이
  됨.


  5.     상속은 과거 코드를 수정하지 않기 위해 사용함. 기저관계


  2) 파생클래스의
  생성자, 소멸자 함수


  1.     생성자, 소멸자함수는 상속되지 않음. à 파생클래스의 소멸자함수는 추가되는 멤버데이터를 고려해야.


  2.     파생클래스의 생성자함수를 호출하면 먼저 기반클래스의 생성자함수가 수행되고 파생클래스의 생성자함수가
  수행됨.


  3.     명시적(콜론(:)
  초기화)으로 기반클래스의 생성자함수를 선택 호출할 수 있음.


  4.     선택하지 않으면 기반의 디폴트 생성자함수가 호출 (묵시적
  콜론 초기화)


  5.     소멸생성자는 역순으로 호출 (1..파생클래스 2..기반클래스)


  3) 참조


  1.     기반클래스의 포인터와 참조는 파생클래스로 만들어진 개체를 포인트, 참조할 수 있음.


  2.     구조체를 부모로 둔 파생클래스의 개체는 부모 구조체 포인터로 접근 가능


  4) 재정의


  1.     기반클래스의 멤버함수를 파생클래스에서 다시 정의하는 것


  2.     재정의 된 멤버함수는 상속되지 않음.


  3.     클래스 이름과 Scope 연산자(::)를 이용해서 구분 호출가능


  4.     기반클래스의 포인터나 레퍼런스는 파생클래스로 만들어지는 개체를 접근할 수 있음.


  호출할 때 파생클래스에
  재정의 된 멤버함수가 아닌 기반클래스의 멤버함수가 호출됨. (포인터, 레퍼런스로 호출한 경우)


  포인터 변수가 가리키는 개체가
  누구인지 식별되기 전에 포인터 변수의 타입으로 함수의 바인딩이 먼저 진행되기 때문에 발생하는 문제임.


  함수의 바인딩을 포인터 변수가
  가리키는 개체의 식별이 가능한 시점 즉, 런타임에 이루어지는 동적 바인딩으로 문제 해결!


  5.     정적 바인딩: 컴파일시에 번지가 결정됨 à 파생클래스의 재정의 함수를 포인터로 호출하면 기반 클래스 주소로 이동하는 문제.


  6.     동적 바인딩: 런타임에서(실행시에) 번지가 결정됨 (느림)


  7.     런타임에 바인딩하라고 지시하는 것이 Virtual à 원활하게 재정의할 수 있게 도와줌.


  
 
 
  
  5) 가상함수(Virtual Function)


  1.     파생클래스의 재정의된 함수를 포인터나 레퍼런스로 잘 호출할 수 있도록 도와줌 


  2.     기반 클래스의 재정의할 함수 앞에 Virtual을
  붙여줌


  3.     기반 클래스의 소멸자도 Virtual을 붙이자.


  4.     가상함수는 동적 바인딩을 위해 사용 (좀 느림)


  5.     가상함수를 쓰면 4Byte만큼 공간 증가. (포인터)


  6.     Virtual 함수는 그 함수가 생성될(재정의될) 때까지
  기다렸다가 그걸 포인트해준다는 것으로 이해하자.


  7.     재정의 될 것 같은 함수는 virtual함수로 만들자.


  8.     순수 가상함수: 함수 선언문에 =0 값을 갖고 있고, 정의부가 없는 가상함수.


  9.     추상 클래스: 순수 가상함수를
  포함하고 있는 클래스.


  è  객체 생성이 불가능함!


  6) 클래스 멤버
  포인터


  1.     형식:


  자료형 클래스명 ::* 변수명; 


  2.     선언 시 개체 없이 초기화할 수 있지만 기억공간의 실제 번지를 갖는 것은 아니며 상대번지로
  초기화


  자료형 클래스명 ::* 변수명 = &클래스::멤버명; 


  3.     멤버함수를 접근하기 위한 용도로 주로 사용


  4.     주의점


  static 멤버는 접근할 수 없습니다.(static 멤버는 전역)


  참조형 멤버데이터는 접근할 수
  없습니다


  멤버 포인터는 일반적인 포인터처럼 증가 또는 감소시킬 수 없습니다.


  
 



