


 
  
  4) 3-State Output (Cont’d)


  1.     Hi-Z 상태는 선택적으로 아무런 출력없이 floating되도록 만들어야 하는 경우에 사용된다.


  2.     여러 신호를 하나로 묶어서 선택적으로 하나의 출력을 지정하는 경우에 사용된다.


  3.     Open-Drain이 아니므로 외부 Pull-Up 저항 불필요하며
  Wired-AND는 불가능하다.


  5) 3-State Output 출력의 활용


  1.     GPIO에 LED를 연결하고 점등시키는 법


  마이컴 내부 메모리에 프로그램을 writing 시켜야 함.


  NXP의 ISP(In System Programming)을
  위해 회로를 구성해보자.


  2.     실습:


  가상 COM 드라이버 설치


  가상 COM 포트 확인


  Flash
  Magic 설치


  ISP 이용해 프로그램 writing


  Memory
  Map 확인


  컴파일러 설치


  GCC 컴파일러 대신 CooCox IDE 설치


  CoIDE
  실행


  3.     LED ON 매크로


  
   
    
    #define Macro_Set_Bit(dest,
    pos)                      ((dest) |=  ((unsigned)0x1<<(pos)))


    #define Macro_Clear_Bit(dest,
    pos)                    ((dest) &= ~((unsigned)0x1<<(pos)))


    #define Macro_Invert_Bit(dest,
    pos)           ((dest) ^=  ((unsigned)0x1<<(pos)))


    #define Macro_Clear_Area(dest,
    bits, pos)             ((dest) &= ~(((unsigned)bits)<<(pos)))


    #define Macro_Set_Area(dest,
    bits, pos)               ((dest) |=  (((unsigned)bits)<<(pos)))


    #define Macro_Invert_Area(dest,
    bits, pos)            ((dest) ^=  (((unsigned)bits)<<(pos)))


     


    #define Macro_Write_Block(dest,
    bits, data, pos)        ((dest) = (((unsigned)dest) & ~(((unsigned)bits)<<(pos)))|(((unsigned)data)<<(pos)))


    #define Macro_Extract_Area(dest,
    bits, pos)           ((((unsigned)dest)>>(pos)) & (bits))


    #define Macro_Check_Bit_Set(dest,
    pos)                ((((unsigned)dest)>>(pos)) & 0x1)


    #define Macro_Check_Bit_Clear(dest, pos)                     (!((((unsigned)dest)>>(pos)) & 0x1))


    
   
  

  
  
 
 
  
  6) GPIO 비트처리에 편리한 레지스터


  1.     LPC810에 있는 CLR, SET, NOT register들을 활용하자.


  2.     SET0 = 0x1<<2 와 같이 레지스터 셋에 직접 값을 입력하면 매크로로 입력한 것도 동일하게 동작한다. (더 빠르다)


  3.     ex)


  LPC_GPIO_PORT->SET0
  = 0x1<<2;  //2번 비트를 1로 셋


  LPC_GPIO_PORT->CLR0
  = 0x1<<2;  //2번 비트를 0으로 클리어


  LPC_GPIO_PORT->NOT0
  = 0x1<<2;  //2번 비트를 반전


   


  <6과. UART와 RS232 통신>


  1) UART (Universal Synchronous Asynchronous Receiver
  & Transmitter)


  1.     USART는 범용 (직렬) 비동기 송수신 장치


  2.     Synchronous 통신 기능이 없으면 UART라고 부른다.


  3.     직렬(serial) vs. 병렬(parallel) à ‘A’ 를 보내려면?


  직렬전송: 1비트의 데이터 버스를 이용해 8비트를 순차적으로 보냄.


      느리지만
  원거리일수록 비용이 싸다.


  병렬전송: 8비트의 데이터 버스를 이용해 0x41을 한번에 보냄.


      빠르지만
  원거리일수록 비용이 많이 든다.


  2) 통신 프로토콜


  1.     두 장치가 통신을 하려면 데이터 형식에 대한 약속(protocol)이
  필요하다.


  2.     UART Frame Format


  Start
  bit 이후 약속한 bit 수 만큼의 data bit와 parity bit 전송


  Stop
  bit로 완료.


  3.     UART는 데이터 통신속도 (bps – bit per sec)에 따라 비트가 전송된다.


  3) 동기 vs 비동기


  1.     데이터를 수신할 때 전송 속도에 맞춰서 데이터 인식해야 함.


  2.     데이터를 인식하는 시점을 파악하기 위해 clock 필요


  3.     동기 (synchronous 통신): USRT


  데이터와 clock이 함께 제공되어 수신측에서 clock에 따라 데이터를
  인식함.


  원거리 전송시 data 폭이 넓거나 좁게 변화되어도 clock이 따라서 변하기
  때문에 문제가 없다.


  고속, 원거리 송수신에 적합하지만 clock 때문에 비용이 큼.


  4.     비동기 (asynchronous 통신): UART


  데이터만 전송하고 clock은 없음.


  송수신단은 각자의 clock 기준에 따름


  데이터 폭의 변화에 따라 잘못
  인식할 수 있음.


  저속, 근거리 송수신에 적합하고, 데이터만 전송해서 비용이 작다.


  4) 송수신 방식과 parity


  1.     UART 데이터 송수신


  TxD(데이터 송신), RxD(데이터 수신), GND(신호레벨 맞추는 기준전압)


  2.     Full Duplex 통신 가능


  3.     Half Duplex: 워키토키 (한쪽은 송신, 다른쪽은 수신)


  4.     Simplex: 단방향 통신 (한쪽 방향으로만 데이터가 전송됨)


  5.     parity bit: 수신된 데이터에 오류가 있는지 판단하기 위함.


  
 



