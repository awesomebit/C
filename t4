


 
  
  1) 메시지 큐


  1.     메시지 큐를 사용하면 프로세스들끼리 자료를 손쉽게 교환할 수 있다.


  id_msg
  = msgget((key_t)KEY_MSG, 0666|IPC_CREAT);


  ret
  = msgsnd(id_msg, (void*)&msgarr[i], sizeof(struct msg_buf) –
  sizeof(long), 0);


   


  ret
  = msgrcv(id_msg, (void*)&msgbuf, sizeof(struct msg_buf) – sizeof(long), mtype, IPC_NOWAIT);


   


  2) 스레드


  1.     스레드는 프로세스 내에서 실행되는 흐름의 단위이다.


  2.     하나의 프로세스에 속한 스레드들은 프로세스 내의
  모든 자원을 공유한다.


  3.     장점:


  자원공유가 쉽다


  기다리는 작업 처리가 용이하다.


  비용이 적게 든다.


  4.     단점:


  동시성 문제 있음.


  문제 발생 시 디버깅이 어려움.


  성능 저하가 발생할 수 있다.


  하나의 스레드의 문제가 프로세스
  전체에 영향을 미침.


  5.     스레드 종료 조건


  스레드 루틴에서 pthread_exit() 호출


  스레드 루틴의 시작함수에서 리턴


  è  시작함수가 종료 == 스레드가 종료


  스레드 루틴에서 exit() 호출


  메인 루틴 종료


  메인 루틴에서 pthread_cancel() 호출


  6.     뮤텍스


  뮤텍스를 이용하여 상호 배제 구간을
  만든다.


  7.     POSIX 세마포어


  세마포어 파일을 매게로 동기화를
  구현.


  주로 프로세스 간 동기화에 사용함.


  이름있는 세마포어 / 이름없는 세마포어


  8.     Reentrant 함수


  둘 이상의 스레드가 동시에 호출하더라도
  병렬로 실행되며, 항상 실행 결과가 동일하다.


  정적공간을 사용하지 않기 때문.


  9.     MT-safety 함수


  둘 이상의 스레드가 동시에 호출해도
  안전하다.


  병렬로 실행되지 않을 수 있고
  실행 결과도 때에 따라 다르다.


  Reentrant
  함수는 MT-safety 함수이지만
  그 반대는 아님.


   


  3) 리눅스 커널


  1.     커널 스레드: 


  커널 공간에서만 존재하는 스레드. 커널은 프로세스 단위가 아니라 스레드 단위로 관리하고 스케줄링하며, 보통
  ‘태스크’라고 한다.


  2.     task_struct 객체: 


  커널은 태스크를 이 객체로 표현한다.


  태스크를 관리하기 위한 모든 정보를
  포함함.


  3.     태스크 상태 전이


  TASK_RUNNING
  (실행중 / 대기중)


  TASK_INTERRUPTIBLE
  / TASK_UNINTERRUPTIBLE


   (시그널에 반응 / 무반응)


  TASK_STOPPED


  4.     프로세스 복제


  _do_fork()
  à copy_process() à dup_task_struct(), copy_files(),
  alloc_pid()


  5.     Copy-on-Write


  fork()
  이후 쓰기 작업이 일어나야 복제 작업이 진행됨.


  è  복제할 때 쓰는 자원을 최소화할 수 있음.


  è  자식은 task_struct 가리키기는 것으로 만들기.


  è  쓰기는 완전히 복제, exec()은 새 자원 갱신(불필요한 복제가 없음)


   


  4) 리눅스 커널 - 프로세스 관리


  6.     I/O bound : 사용자 입력을 기다리는


  7.     CPU bound : 프로그램 코드를 실행하는


  8.     문서 편집기는 대부분 I/O bound 동작, 단어 검색시 CPU bound à 리눅스 스케줄러는 두 가지 성격 모두 만족함.


  9.     프로세스 스케줄링 정책


  일반 프로세스 (SCHED_NORMAL): 나이스 값이 작을수록
  우선순위 높음


  실시간 프로세스 (SCHED_FIFO): 실시간 우선순위값이 클수록
  우선순위 높음


  우선순위가 높을수록 더 많은 CPU 사용시간 할당받음.


  10.  O(1) 스케줄러


  나이스 값에 따라 절대적인 타임
  슬라이스가 결정됨.


  11.  CFS 스케줄러


  나이스 값에 따라 할당 비율을
  결정함.


  12.  실시간 프로세스 우선순위


  SCHED_FIFO : 타임 슬라이스 할당이 없는 FIFO 구조의 알고리즘


  SCHED_RR : 타임 슬라이스가 있는 SCHED_FIFO


  13.  소프트웨어 인터럽트


  특정 위치로 점프하고 CPU 모드를 커널모드로 변경함.


   


  5) 리눅스 커널 – 메모리 관리


  1.     페이지: 리눅스는
  물리 메모리를 페이지 단위로 나누어서 관리함 (4KB)


  2.     페이지 테이블: 가상 주소를
  물리 주소로 변환해주는 테이블


  3.     페이지 프레임 배열은 물리 메모리에 저장된다.


  4.     물리 메모리가 배정되지 않은 가상 메모리를 액세스하면 page fault가 발생하고, 소프트웨어 인터럽트가
  발생한다.


  5.     소프트웨어 인터럽트는 메모리를 특정 영역으로 이동시킨 후
  kernel mode로 전환함.


  6.     커널 주소 공간


  유저 주소 공간과 커널 주소 공간으로
  구분됨.


  Lowmem,
  vmalloc, pkmap, fixmap


  7.     GFP 플래그: 메모리 할당
  시 영역, 동작, 유형을 지정함.


  8.     kmalloc(): 메모리를 바이트 단위로 할당함


  GFP
  flag를 설정해 상세한 설정할 수 있음. 인터럽트 핸들러처럼 sleep이 되지 않는 상황에서 사용 가능.


  9.     vmalloc(): 메모리를 바이트 단위로 할당하지만, GFP 플래그는
  사용 불가.


  연속이 아닌 물리 메모리 할당 (큰 메모리를 할당 가능)


  10.  high memory 연결


  kmap(),
  kunmap(), kmap_atomic(), kunmap_atomic()


  high
  memory의 가상 주소 영역은 커널 주소 영역의 pkmap에 배정된다.


  11.  vm_area_struct는 하나의 세그먼트를 표현함.


  12.  mm_struct에 의해 vm_area_struct들이 관리된다.


   


  6) 리눅스 커널 – 파일시스템


  1.     FAT 파일 시스템


  빌 게이츠와 마크 맥도널드가 1976년 개발


  현재는 발전된 NTFS가 윈도우 NT 계열에서 사용됨.


  복구성과 보안성이 향상됨.


  2.     ext2 파일 시스템


  3.     VFS (Virtual File System)


  수많은 파일시스템을 하나처럼 보이게
  한다.


  중간역할. APP이 어떤 파일에 접근할 때 어떤 파일시스템인지, 어디에
  저장돼있는지 신경쓰지 않도록.


  super_block, inode, dentry, file 객체


  4.     파일시스템 디버깅. Read, write, open 함수
  안 구조체 연결구조 분석함.


  
 
 
  
  <커널 포팅>


  1) 커널 설정


  1.     리눅스 커널의 구성 요소를 선택할 수 있다.


  2.     커널 설정 명령어


  $
  make config


  $
  make xconfig


  $
  make menuconfig


  $
  make defconfig


  3.     ?= 명령어는
  좌변의 변수가 비어있으면 우변을 대입함.


   


  2) 커널 컴파일


  1.     리눅스 커널을 컴파일하여, 커널 이미지를 생성한다


  2.     커널 컴파일 명령어


  $
  make Image


  $
  make zImage


  $
  make uImage


  $
  make modules


  $
  make modules_install


  $
  make dtbs


  $
  make clean


  $
  make distclean


  최상위 디렉터리에서 실행해야하며, 기능은 Makefile 내에 구현되어 있다.


  3.     .config 로부터 2가지 결과물이 만들어짐: 


  auto.conf,
  autoconf.h


  4.     컴파일 하는 대상은 Makefile에서
  지정한다.


  obj –y
  (커널 이미지에 포함)


  이를 통합하면 built-in.o 생성


  built-in.o
  와 다른 오브젝트들을 통합하면 vmlinux 생성


  vmlinux로부터 Image, zImage, uImage 등
  가공.


  5.     vmlinux 생성 시 vmlinux.lds 파일을 참조함.


  vmlinux
  내용은 System.map으로 표현됨.


   


  3) 디바이스 트리


  1.     노드의 표현


  name
  { … };


  최상위에 있는 노드를 /(루트 노드)라고 함.


  2.     디바이스 트리에서 커널 이미지를 설정할 수 있음.


  커널 이미지를 바꾸지 않아도, 디바이스 트리로 유연하게 설정해서 쓸 수 있다.


  3.     속성의 표현


  property
  = value;


  4.     노드 이름 규칙


  <name>[@<unit-address>]


  <name>은 31글자 이하의 아스키 문자열, 디바이스의 종류


  <unit-address>는 선택적으로 사용 (reg속성 주소)


  5.     디바이스 표현


  각 디바이스는 노드로 표현되고, compatible 속성을 갖는다.


  6.     디바이스의 compatible 속성은 커널에서 어떤
  디바이스를 사용할지 결정하는 키가 된다.


  속성 값은 여러 개 기입할 수
  있는데, 맨 앞의 값은 정확하게 기입하고, 뒤에 나오는
  값들은 호환되는 장치를 의미하는 값을 기입한다.


  7.     주소범위를 표현하는 속성


  #address-cells
  : 주소를 표현하는 셀의 개수


  #size-cells
  : 크기를 표현하는 셀의 개수


  예시) 디바이스의 주소 표현


  #address-cells = <1>;


  #size-cells = <1>;


  à주소셀 1개, 크기셀 1개


  8.     range 속성


  <child-address1
  parent-address1 childe-size1 [child-address2 parent-address2 childe-size2] …>


  9.     인터럽트 표현


  Interrupt-controller 속성: 항상 비어있는 속성으로, 자신이 인터럽트 컨트롤러임을 표현


  #interrupt-cells
  속성: interrupts 속성을
  표현하는 셀의 개수 지정


  interrupt-parent
  속성: 자신이 속한 인터럽트 컨트롤러
  표현, 생략 시 부모 노드의 속성을 상속받음.


  Interrupts
  속성: 인터럽트 번호 및 특성을 표현


   


  4) 부트로더


  1.     부팅 순서


  iROM
  -> BL1 -> BL2 -> U-Boot -> kernel


  2.     부트로더는 시스템을 시동(Booting)하고 OS를 로딩(Loader)한다.


  3.     U-Boot 특징:


  다양한 종류의 CPU 지원


  임베디드 시스템에 적합


  보드에 맞게 포팅 가능


  다양한 통신 수단 제공


  다양한 저장 장치 지원


  유용한 디버깅 환경 제공


  4.     빌드 후 생성되는 주요 파일


  u-boot.map,
  u-boot, u-boot.bin


  5.     fastboot : USB를 통해 저장장치를 직접 제어하는 U-Boot 명령. 


  주로 안드로이드 기기에서 사용되며, 저장장치를 파티션으로 구분하여 제어한다.


  
 
 
  
  5) 부트로더와 커널 초기화


  1.     시스템 초기화 과정


  _start (U-Boot 시작)


  board_init_f()


  board_init_r()


  ----------------------------------커널로 이동


  stext


  start_kernel()


  RFS 마운트


  init 프로세스 시작


  idle 상태


  2.     U-Boot의 ENTRY 포인트는 _start


  3.     리눅스 커널의 ENTRY 포인트는 stext


  4.     start_kernel() : 최초의 C 함수.


  5.     아키텍처 초기화


  2가지 방법으로 머신 초기화할 수 있음.


  Device Tree 기반


  U-Boot에서 넘어온 machid 기반


  6.     커널 초기화


  rest_init()
  à kernel_thread() 커널스레드 실행 à kernel_init() à kernel_init_freeable() 초기화작업 진행 à do_basic_setup() //
  __initcall0_start 와 __initcall_end 사이에 있는 함수들을 순서대로 호출.


  prepare_namespace() 루트파일시스템
  마운트


   


  6) 머신 추가


  1.     커널 포팅: 원하는 하드웨어에서
  리눅스 커널을 동작시키기 위해서 수정하는 작업


  2.     machine_desc 구조체 : 머신 정보


   


  <디바이스
  제어>


  1) 디바이스 드라이버


  1.     문자 디바이스 드라이버: 바이트로 액세스


  2.     블록 디바이스 드라이버: 블록 단위로 액세스


  3.     네트워크 인터페이스 드라이버: 패킷 단위로 앳세스


  4.     디바이스 파일


  /dev
  디렉터리에 모아져있음.


  디바이스 파일은 일반 파일과 특성이
  다르고,


  mknod
  명령으로 만든다.


  5.     Major 번호: 디바이스 드라이버의 고유번호


  6.     Minor 번호: 디바이스 드라이버가 제어하는 장치 번호


   


  2) 모듈


  1.     커널 구성 요소와 디바이스 드라이버를 모듈로 만들 수 있음.


  2.     소스코드는 건드리지 않고 커널 이미지가 작아지는 장점, 필요할
  때 로드하지만 속도는 느려지지 않음.


  3.     insmod – 모듈 로딩, rmmod – 모듈 언로딩


  4.     모듈 매크로


  module_init
  매크로를 쓰는 이유:


  소스코드를 수정하지 않고도, 모듈 컴파일과 커널에 포함한 컴파일 둘 다 가능하기 때문.


  5.     모듈 파라미터


  모듈 파라미터를 사용하면 초기값을
  처음에 지정해줄 수 있다.


   


  3) 문자 드라이버


  1.     디바이스 번호


  Major
  번호와 Minor 번호를 모두 포함한다.


  dev_t
  타입으로 표현


  고정할당: register_chrdev_region()


  자동할당: alloc_chrdev_region()


  2.     inode 구조체


  디바이스 번호를 표현함


  3.     file 구조체


  f_flags:
  O_RDWR, O_RDONLY, O_NONBLOCK


  f_ops:
  해당 파일의 file_operations 객체를
  카리킴


  4.     디바이스 파일의 역할: 디바이스 드라이버와 APP을 연결시켜주는 매개체.


  응용프로그램à디바이스파일àfile_operationsàD/D함수


  5.     cdev 구조체


  owner:
  cdev를 사용하는 모듈, THIS_MODULE 초기화


  ops:
  file_operations 객체 주소


  dev:
  디바이스 번호


  count:
  Minor 번호 개수


  6.     API


  동적할당: cdev_alloc()


  cdev객체 초기화: cdev_init()


  문자 디바이스 등록: cdev_add()


  7.     xxx_open, xxx_release


  file_operations
  객체 안에 추가:


  .open
  = device_open,


  .release
  = device_release,


  8.     xxx_read, xxx_write


  9.     xxx_ioctl


  
 
 
  
  <하드웨어
  인터페이스와 인터럽트>


  1) 하드웨어 인터페이스


  1.     I/O포트


  CPU가 주변장치에 액세스하기 위한 버스 인터페이스 영역


  2.     I/O메모리


  CPU가 주변장치에 액세스하기 위한 하나의 버스 인터페이스 영역


  버스 인터페이스는 하드웨어 레지스터에
  액세스하기 위해 필요하다.


  3.     I/O 포트용 API 도 컴파일하면 I/O 메모리에서
  사용할 수 있다. I/O메모리만 있는 장치가 있기 때문에 이러한 범용성이 필요하다.


  4.     I/O 메모리 API


  request_mem_region()
  à I/O 메모리를
  할당


  release_mem_region()
  à I/O 메모리 반납


  ioremap()
  à 가상 주소를
  배정함


  ioremap_nocache()
  à 캐시를 끄고
  가상 주소를 배정함


  iounmap()
  à 가상 주소를
  반납


  5.     RAM에서 데이터를 읽어올 땐 cache를 사용하는 게 더 빠름.


  ioremap()
  은 cache가 꺼져있는데, cache에 쓰고 읽은 값이 물리메모리에 적용되기까지 딜레이가 있기 때문임.


   


  2) 인터럽트


  1.     인터럽트 컨트롤러는 레지스터에 액세스해서 누가 인터럽트를 걸었는 지 확인함.


  2.     인터럽트 컨트롤러가 여러 개인 경우 상하구조의 계층을 가짐
  (Exynos4412)


  KEYàGPX0àGICàCPU


  ADC(아날로그 신호를 디지털 신호로 변환)àCombineràGICàCPU


  3.     인터럽트 계층 구조는 디바이스 트리를 이용해 표현함.


  4.     H/W IRQ 번호는 인터럽트 컨트롤러에 따라 고정된 물리적 번호임


  인터럽트 컨트롤러가 여러 개인
  경우, H/W IRQ 번호가 겹치므로, Linux IRQ 번호를
  동적으로 할당받아 사용한다.


  è  irq_domain 구조체 운용


  5.     인터럽트 등록 및 해제


  request_irq()
  à 인터럽트
  등록


  request_threaed_irq()
  à request_irq()에서 thread_fn 추가.


  6.     인터럽트 플래그


  7.     인터럽트가 걸리면 인터럽트 핸들러가 실행된다.


  8.     인터럽트 핸들러 주의사항


  CPU가 커널 코드를 실행 중일 때는 프로세스 문맥이거나, 인터럽트
  문맥임.


  A)    프로세스 문맥:


  a)    유저 영역에서 실행 중인 프로세스가 시스템콜에 의해 커널 영역에 진입한 경우


  b)    커널 스레드를 실행 중인 경우


  B)    인터럽트 문맥:


  a)    인터럽트 발생 시 실행되는 커널 동작임


  b)    Sleep 불가 //단, kmalloc() 은 GFP_ATOMIC 플래그를 추가하면 사용할 수 있다.


  c)     스케줄링 불가


  d)    공유되는 자원을 spinlock으로 보호해야 함


  e)    유저 공간과 데이터 교환 불가


  f)     빠르게 처리하고 리턴.


   


  <시간처리>


  1) 시간처리


  1.     Jiffies 카운터


  타이머 인터럽트가 발생할 때마다
  내부적으로 jiffies가 1씩 증가한다.


  부팅 시에 0으로 초기화되고 1초에 HZ만큼
  증가한다.


  2.     긴 지연 (Long Delay)


  A)    바쁘게 기다리기(Busy waiting)


  T1 = jiffies + HZ;


  while (time_before(jiffies, t1))
  cpu_relax();


  비선점형 커널이라면 성능이 크게 저하됨


  선점형 커널 역시 성능 저하 발생


  지연시간이 정확하다는 장점있음.


  B)    양보하기


  T1 = jiffies + HZ;


  while (time_before(jiffies, t1)) schedule(); //양보함


  schedule()을 호출하여 기다리는 동안 다른 프로세스에 CPU를
  양보한다


  지연 시간이 정확하지 않다. 


  다른 프로세스가 바쁘게 돌아가면
  시간 오차가 커짐


  3.     짧은 지연 (Short Delay)


  delay
  : 정확한 지연 시간


  sleep
  : 지연 시간이 정확하지 않음


   


  2) 지연된 작업


  1.     커널 타이머


  일정 시간 후에 정해진 작업을
  할 수 있다.


  타이머 핸들러는 인터럽트 핸들러처럼
  비동기적으로 실행되는 인터럽트 문맥이다.


  Sleep,
  스케줄링 불가


  2.     tasklet


  인터럽트가 남겨놓은 작업을 나중에
  처리한다 (지연 작업)


  Tasklet
  핸들러는 커널이 알아서 실행하고, 동기화
  문제가 없다.


  급하지 않은 일이나 연산을 ‘지연된 작업’으로 넘겨서
  tasklet이 처리함.


   


  3) 커널 동기화


  1.     임계 영역: 공유 자원에 접근하는 코드 영역


  2.     동시성 문제: 세마포어로 해결


  3.     동시성 문제 원인:


  인터럽트, 지연 함수, 선점형 커널,
  SMP시스템


  
 
 
  
  4) 스핀락


  1.     세마포어보다 효율적. 세마포어는 sleep으로 넘기고, 스핀락은
  spinning으로 기다리게 한다.


  2.     스핀락을 획득하면 임계영역이 선점이 비활성화됨.


  3.     따라서 스핀락 내에 코드는 원자적으로 수행되어야 함.


  4.     Sleep 불가. 인터럽트 문맥 불가.


  5.     “원자적” : 다른 태스크 스케줄링이 불가능하고, 끝날
  때까지 실행되었던 그 태스크만 실행함.


  6.     세마포어는 임계영역에서 sleep이 가능하기 때문에
  인터럽트 핸들러에서 사용할 수 없다.


   


  5) wait queue


  1.     시간 지연 + 추가 컨디션


  2.     깨어나는 경우:


  Condition이 참인 경우


  Timeout인 경우


  Interruptible
  wait queue의 경우 시그널을 받는 경우


   


  6) Blocking 모드


  1.     디폴트는 Blocking 모드 (잠이 든다)


  2.     O_NONBLOCK 플래그를 사용하면 Nonblocking 모드.


  3.     O_NONBLOCK 모드 시


  Read()
  : 유효한 데이터가 없으면 즉시 에러 리턴


  Write()
  : 데이터를 쓸 공가니 없으면 즉시 에러 리턴


   


   


  <디바이스
  모델>


  1) Bus, Device, Driver


  1.     sysfs 파일시스템: 커널의 데이터 구조, 속성, 인터페이스를 제공하는 ram-based 파일시스템.


  2.     디바이스 모델: Bus, Device, Driver 구조로
  표현되는 통일된 데이터 모델


  3.     Bus : CPU와 디바이스를 연결하는 물리적인 매체.


  4.     Class : SCSI disk와 ATA disk는 모두 disk로써 같은 Class에 연결된다.


   


  2) 플랫폼 드라이버


  1.     풀랫폼 버스: 물리적으로 존재하지 않는 가상 버스


  플랫폼 Device의 name과 플랫폼
  Driver의 driver에 포함된 name을
  비교해서 동일하면 probe() 호출.


  
 



