


 
  
  <개요>


  1.     컴퓨터 구조


  
  2.     platform이란?


  작업할 수 있는 공간. 작동할 수 있는 틀. (컴퓨터 운영체제)


  플랫폼을 수정해서 쓸 수 있다. 예를 들어서 구글이 안드로이드 플랫폼을 제공하면 스마트폰 제조사들은 이 플랫폼을 입맛에 맞게 수정해서 쓸
  수 있다.


  3.     bootloader란?


  실행할 파일을 로딩한다. DRAM이나 NAND FLASH를 부트초기화하고 이 곳에 로딩한다.


   


  <시스템 프로그래밍>


  1과. ARM cortex-A/R/M 프로세서


  1.     big.LITTLE (Cortex-A7 MPCore 프로세서)


  기기에서 고성능 작업이 필요할
  땐 Cortex A15 코어가, 저성능 작업을 할 땐 Cortex A7 코어가 사용될 수 있도록 하는 기술.


  2.     Exynos 4412


  ARM에서 IP로 파는
  MPU를 사서 주변장치(Peripherals)를 개발해 붙인 것.


  이를 통합해 SoC라고 부른다.


   


  2과. 어셈블리에 의한 GPIO 제어


  1.     시스템 초기 설정 요소


  BIOS:
  Basic Input and Output System


  프로세서를 사용 가능하도록 최소한의
  ㅏ전 설정 작업


  uBOOT가 이 역할을 담당함.


  이후 OS 또는 응용프로그램을 실행한다.


  ROM
  / DRAM에서 실행.


   


  WDT:
  Watch Dog Timer


  전원 인가시 Enable 상태


  주기적으로 시스템 리셋 발생 à 보통 초기에 disable하기


   


  2.     레지스터


  WDT를 disable하려면 WTCON 레지스터에 0을 대입.


   


  CPU 와 주변장치 레지스터 차이점:


  CPU 레지스터는 CPU 특수목적으로 사용하기 위해 등록한
  메모리.


  주변장치 레지스터는 해당 장치가
  특수목적으로 사용하기 위해 등록된 메모리.


  CPU 입장에서 주변장치의 레지스터는 메모리와 같다.


   


  3.     Memory Mapped I/O


  CPU 내부에 있는 레지스터는 R0 ~ R15와 CPSR, SPSR 등의 레지스터임.


  GPIO는 ARM CPU Core 의 AMBA(메모리 버스)에 접속된 주변장치이다.


  주변장치 레지스터가 CPU 입장에선 메모리이고, 이 주변장치가 바로 Memory Mapped I/O.


  è  이러한 레지스터들은 고유 주소를 가짐.


  
 
 
  
  2과. 어셈블리에 의한 GPIO 제어
  (Cont’d)


  1.     Load, Store 개념


  MOV 명령:


  대부분 RISC는 여러 개의 범용 레지스터들을 파일 구조로 구성.


  연산은 이들 레지스터들에서만 이루어진다. 따라서 연산의 대상으로 외부 메모리를 직접 사용하지 못하고, 외부
  메모리는 반드시 레지스터를 거쳐서 연산이 이루어진다.


  è  주변장치의 레지스터는 메모리이므로 MOV 명령으로
  처리 불가하고, 레지스터/메모리 간 데이터 이동 명령이
  필요함


   


  LOAD,
  STORE


  레지스터 ß 메모리 : LDR(Load to Register)


  레지스터 à 메모리 : STR(Store to Memory)

  

  


  2.     LDR 명령


  Ldr Rn,
  =value


  ARM은 레지스터간 데이터 복사는 MOV 명령을 사용.


  Rn:
  r0 ~ r15, 대소문자 구분 없음.


  =value:
  상수값 지정. 최대 4바이트


   


  3.     레지스터 간접참조


  Ldr Rd,
  [Rs]


  Rs 레지스터 값을 메모리 주소로 하여 내용을 Rd로
  load.


   


  예시)


  LDR
  r0, =0x1000


  LDR
  r1, =80


  STR
  r1, [r0]


   


  예시) WDT 제어


  LDR
  r0, =0x10060000


  LDR
  r1, =0x0


  STR
  r1, [r0]


   


  4.     ARM 데이터 처리


  +, -
  연산군:


  ADD,
  ADC, SUB, SBC, RSB, RSC


   


  비트 연산군:


  AND,
  ORR, EOR, BIC


  AND:
  원하는 비트를 0으로 클리어


  ORR:
  원하는 비트를 1로 set


  EOR:
  원하는 비트만 반전


  BIC:
  원하는 비트만 0으로 클리어 (AND보다 편리)


   


  MOV 연산군:


  MOV,
  MVN


   


  비교 연산군:


  CMP,
  CMN, TEQ, TST


   


  5.     상수 표현


  # 상수:


  32비트 명령 내에 상수값을 저장 (0~255 범위
  상수)


   


  LDR
  vs. MOV

  mov 명령이 더 효율적임. ldr은 다른 공간에 데이터를 복사해야 함(떨어진 곳에 있는 32비트 값을 가져온다)


   


  MOV
  R0, #12345678


  ==


  LDR
  r0, =12345678


  LDR
  r1, =0x1000


  STR
  r0, [r1]


   


  6.     LSL, LSR shift (Logical Shift à 빈 자리에 무조건 0)


  LSL
  #n: 최후에 밀려난 비트가 C(Carry) flag에 저장됨.


    Signed/unsigned * 2


  LSR
  #n: 최후에 밀려난 비트가 C(Carry) flag에 저장됨.


    Unsigned / 2, 비트 shift


   


  7.     ASR shift (Arithmetic Shift à 빈 자리에 부호 비트 값)


  ASR
  #n: MSB(부호) 유지, 밀려난 비트는 C flag 에 저장.


   


  8.     ROR, RRX shift


  ROR
  #n: Rotate Right. 밀려난 비트는 C flag에 저장


  RRX:
  Carry 포함해
  Rotate Right. 무조건 1비트만 가능.


   


  9.     TST, TEQ


  TST:
  특정 비트 확인


  TEQ:
  비트 패턴 확인용


   


  10.   상태레지스터와 FLAG

  CPSR(Current Program Status Register)


  N(Negative),
  Z(Zero), C(Carry), V(Overflow), Q


   


  11.   분기 명령, 파이프라인 동작


  파이프라인 명령어는 기본적으로 Fetch, Decode, Execute 로 동작. 1사이클당 1명령 수행.


  명령 수행으로 분기가 발생하면, 파이프라인에 미리 저장된 명령은 버려진다.


  ARM의 모든 명령은 조건부 실행이 가능


  è  조건이 참이면 실행, 거짓이면 skip


  è  조건부 실행으로 인해 잦은 분기없이도 조건 명령 실행 가능.


   


  12.   서브루틴 호출


  BL
  label à branch and link


  BL은 서브루틴 호출 명령, label은 서브루틴의
  상대주소 값.


  B와 달리 복귀할 주소를 R14에 저장한다.


   


  13.   특수용도 레지스터 (R13 ~ R15)


  R13
  (SP): 스택의 주소 저장


  R14
  (LR): 함수 호출 시 되돌아갈 함수의 주소 저장.


  R15
  (PC): program counter. 프로그램
  수행시 읽어오는 명령의 주소 저장.


  
 



