


 
  
  <복습>


  1) 부팅


  1.     WDT disable


  (Memory
  Mapped I/O)


  *(volatile
  int*)0x100=0;


  //volatile
  을 붙이는 이유는 컴파일러가 최적화하면서 필요하지 않은 코드 영역을 스킵하는
  부분을 막기 위함.


  2.     LED ON (GPIO)


  3.     I-cache, 분기예측기 ON à 부팅과정을 빠르게 하기 위함.


  //부트로더는 FLASH 에서 필요한 파일을 올리고
  권한을 넘기기 위해서 존재함.


  //초기화 작업을 어셈으로 하기.


  
  --------------------------------------------------------------------------------


  4.     CRT (C runtime startup)


  실행파일과 나머지 파일 구분하자.


  5.     C의 memory


  Memory
  Mapped I/O 영역 à volatile


  MMU 설정 à Code 설정


  개발자가 C 환경에서 프로그램을 개발할 수 있도록 하기.


   


  2) 어셈블리
  명령어


  1.     add, adc(add with carry), sub,
  sub(subtract with carry), rsb, rsc


  2.     ldr, str


  3.     b(bx), bl(blx)


  4.     mov, mvn


  5.     cmp, cmn, tst, teq


  6.     and, orr, eor, bic


  7.     ror, rox


  8.     NZCV:


  [MI,PL],
  [EQ,NE], [VS,VC]


  9.     > GT, >= GE, < LT, <= LE


   


  
   


  <2부> Exception Handling


  <1과. AAPCS와 C-ASM 인터페이스>


  1) Calling Convention


  1.     __cdecl


  C표준.


  장점: 가변인자 전달 가능.


   


  2.     __stdcall


  장점: C콜은 함수 호출 시 마다 스택을 정리하는 명령이 있지만, stdcall
  은 맨 마지막에 스택을 정리하기 때문에 조금 더 효율적.


  단점: 가변인자 전달이 불가능.


   


  3.     __fastcall


  ARM은 fastcall과 cdecl을 섞어쓰는 방식. 스택정리 책임은 caller가. 사용 메모리는 레지스터. 인수 전달 위치는 우측부터 높은 주소.


   


  2) Subroutine 호출과 복귀 명령


  1.     기존 MOV PC 를 BX LR 명령으로 바꿔주자 (v5 이후)


  2.     함수가 끝날 땐 항상 BX LR (리턴명령)이 있어야 함.


  3.     LR (Link Reg.) 에 BL 명령으로 복귀주소를 저장함.


   


  3) ARM-Thumb Interworking


  1.     Thumb 모드 (16 bit), ARM 모드 (32 bit)


  2.     ARM 모드와 Thumb 모드를 왔다갔다하면서 동작할 수 있다.
  이 경우에 전환 시 ‘BL’ 명령을 통해서 전환할 수 있는데, ‘BL’ 명령은 함수 호출시에 ‘LR[0]’ 에 당시 명령체계를
  저장한다.


  3.     ‘BLX’는 T 비트를 무조건 반전시키고 ‘LR[0]’ 를
  사용 안함.


  4.     CPSR의 T 비트: 1àThumb, 0àARM


   


  5.     함수 호출시 명령체계 context 보존과 복원:


  이 부분의 처리가 없다면 ASM 파일에서 C파일을 호출하면 LR안에서 계속 맴돈다. à 스택으로 처리해주자.


   


  str
  lr, [sp, #-4]!   ;;LR을 스택에 대피시킨다.


  bl
  c_func


  ldr
  r, [sp], #4     ;;명령 체계간 interworking이 가능한 리턴


   


  4) FD stack (Full-Descending Stack)


  1.     PUSH 할 때 주소가 감소하는 것.


  2.     SP 는 TOP data 값을 가르킴. EMPTY는 0


   


  5) AAPCS


  1.     ARM에서 함수를 호출할 때 argument를 주고받는 데 약속한 레지스터 값.


  2.     r0~r4, r12 : Scratch Register. 함수를 호출할 대 훼손될 수 있는, 훼손되어도 되는
  레지스터.


  3.     r4~r11 : 호출된 함수로 되돌아가기 위해 LR을 대피시키는 레지스터.


  4.     4B 이하 데이터는 4B로 확장된다.


  5.     실수는 VFP 사용시 VFP 레지스터로 리턴된다.


  6.     구조체, 공용체 등은 4B 이하 데이터는 4B 쓰레기값으로 패딩돼서 확장된다.


  7.     4B 초과 구조체, 공용체에서 caller는 4B 초과 데이터 리턴이 필요한 경우 복사받을 주소값을 R0에
  전달한다.


  8.     Stack을 통한 argument 전달 시, 함수 시작시에 SP는 반드시 8Byte align 상태여야 함.


   


  9.     비효율적인 레지스터의 사용 예시


   


  [1]
  void f(int, double, int); 


     Int à R0 / double à R3, R2 / int à stack


     R4를 쓰지 않고 마지막 인자가 stack에 저장됨.


  [2]
  struct st func(double, int);


     struct st x = func(…);


     x의 주소 à R0 / double à R3,R2 / int à stack


     x의 주소가 R0에 저장되기 때문에 마지막 인자가
  stack에 저장됨.


   


  6) 다중 메모리
  이동 명령: LDM, STM


  1.     LDM (Load Multiple), STM(Store Multiple)


  LDMDB
  r1, {r1-r4, r12, LR}


  , 로 나열 //  - 로 범위 지정


  ‘DB’
  조건부 명령 실행 가능


   


  2.     IA, IB, DA, DB


  IA à increment after


  IB à increment before


  DA à decrement after


  DB à decrement before


   


  3.     레지스터는 반드시 낮은 주소에 낮은 레지스터 번호가 저장된다!


   


  4.     STM, LDM의 특성


  Base
  Register: STM,LDM 수행 뒤에도 항상 고정


  !
  option: auto-update. 모드에 따라
  증가/감소된 값 유지


   


  5.     STMFD, LDMFD 는 FD stack을 위한 PUSH POP!


  PUSH,
  POP 명령을 그대로 써도 된다 (v5 이후) 


  à ^ 옵션은 불가


   


   


  7) Scratch Reg. 보존, 복구, 스택정리


  1.     실습


  Asm_Add_Sqr:


  push
  {r4-r6, lr}  //8Byte align, r6는 dummy reg.


  mov
  r5, r1  //r1 보존


  bl
  Sqr


  mov
  r4, r0  //a^2 보존


  mov
  r0, r1  //b를 전달


  bl
  Sqr


  add
  r0, r0, r4  //a^2 와 b^2 의 합 전달


  pop
  {r4-r6, pc} 


   


  à인자로 들어온 r0, r1 모두 보존해야 함.


   


  8) LDR, STR 명령 형변환


  1.     LDRB: unsigned byte 로딩


  2.     LDRSB: signed byte 로딩


  3.     LDRH: unsigned short 로딩


  4.     LDRSH: signed short 로딩


   


  9) LDRD, STRD


  1.     (Rn+1, Rn)에 데이터를 저장 (Dual Load)


  2.     제약:


  Rn+1,
  Rn 은 연속한 레지스터


  Rn은 반드시 짝수번호 레지스터


  메모리 주소는 반드시 4배수


  Shift
  옵션 사용 불가.


   


  10) UXT, SXT 명령


  1.     char, short를 쉽게 unsigned int로 승격시킬 수 있다.


   


  
 
 
  
  <2과. Mode와 Exception>


  1) Normal 상태


  1.     F-D-E-F-D-,,, 동작이 정상적으로 작동함.


  2.     Fetch, Decode, Execute 를 지속하지 못할 땐 Exception 발생!


   


  2) Exception 발생


  1.     Mode 변경


  2.     Code 작동


   


  3) 8 Processor Modes


  1.     User


  ----------------------------------------------밑은 Privileged Modes


  2.     System


  3.     Superviosr


  4.     FIQ


  5.     IRQ


  -------------------------------밑은 오류


  6.     Abort


  7.     Undefined


  8.     Monitor


   


  4) Exception Vector Base


  1.     Vectoring: Exception이 발생한 경우 H/W적으로 코드를 변경해준다.


  2.     Vector Offset에 따라서 해당 코드로 이동한다.


  3.     설정:


  Vector
  Base + Offset à PC


  Offset은 32bit 테이블이라서 32B Align된 주소로만 설정 가능


  è  MRC p15, 0, Rx, c12, c0, 0 (


  MCR
  p15, 0, Rx, c12, c0, 0


   


  4.     Exception Vector Table


  
   
    
    Exception


    
    
    발생 원인


    
    
    Vector Offset


    
   
   
    
    Reset


    
    
    시스템 리셋


    
    
    0x00


    
   
   
    
    Undefined Instruction


    
    
    정의되지 않은 명령 수행


    
    
    0x04


    
   
   
    
    SVC


    
    
    Supervisor call


    
    
    0x08


    
   
   
    
    SMC


    
    
    Secure monitor call


    
    
    0x08


    
   
   
    
    BKPT


    
    
    Software breakpoint


    
    
    0x0C


    
   
   
    
    Prefetch Abort


    
    
    명령어 fetch 시 메모리 violation


    
    
    0x0C


    
   
   
    
    Data Abort


    
    
    데이터 read 시 메모리 violation


    
    
    0x10


    
   
   
    
    -


    
    
    Reserved


    
    
    0x14


    
   
   
    
    IRQ Request


    
    
    Normal interrupt 발생


    
    
    0x18


    
   
   
    
    FIQ Request


    
    
    Fast interrupt 발생


    
    
    0x1C


    
   
  

   


  5) CPSR, SPSR


  1.     CPSR: 상태레지스터, SPSR: 상태레지스터 저장용


  2.     상태 레지스터 Access 명령:


  MRS(상태 레지스터 à 레지스터), 


  MSR(레지스터 à 상태 레지스터)


  CPS
  (Change Process State) //CPSR 레지스터
  필드 수정


   


  3.     현재 설정 유지하고, irq, fiq mask를 disable 하기:


  MRS
  R0, CPSR


  ORR
  R0, R0, #(0x3<<6)


  MSR
  CPSR, R0


   


  또는,


   


  CPSID
  i


  CPSID
  f


   


  4.     Exception으로부터 복귀는 PC와 CPSR가 동시에 복원되어야
  한다.


  è  ^옵션 사용: SPSR이 CPSR에 copy됨.


   


  6) Exception 처리과정


  1.     프로그램 수행 중 Exception 발생.


  2.     SPSR_mode에 CPSR 백업


  3.     CPSR 수정하고 LR에 되돌아갈 주소 저장(PC - 4)


  4.     Processor가 H/W적으로 처리함


  5.     Exception 업무 처리


  6.     exception handler


  복귀: CPSR ß SPSR_mode / PC ß 복귀주소 동시에 동작


   


  7) Exception 종류


  1.     Undefined Exception


  발생원인: 명령 디코딩시 정의되지 않은 명령어


  2.     Supervisor Call Exception


  발생원인: SVC 명령 수행한 경우


  3.     Prefetch Abort Exception


  발생원인: Fetch한 Code 메모리가
  invalid한 경우.


  4.     Data Abort Exception


  발생원인: Invalid한 데이터 메모리를 Load 또는 Store한 경우. 문제점 해결 후 복구할 때 PC-8.


  5.     IRQ Exception


  발생원인: 프로세서 외부로부터 IRQ 신호가 인가된 경우.


   


   


  <3과. Exception Handler 설계>


  1) Vector Base 필요성 


  1.     Exception이 발생하면 Vector Base 가 없는 경우 주소
  0x0으로 분기하는데, 0x20000000번지에 프로그램이 다운로드하여 실행된 경우
  0x0번지에 아무런 코드가 없어서 문제가 발생함.


   


  2) UND 핸들러


  1.     main() 함수에서 Exception 발생 (Main.c)


  2.     Vectorin으로 Undef_Handler로 이동 (crt0.s).
  undefined mode로 변경됨.


  3.     Undef_Handler()로 분기해서 무한루프 상태로 전환 (Exception.c).


   


  4.     무한루프 전에 디버깅 정보 출력하기:


  HandlerUndef:


  SUB r0, lr, #r


  MRS r1, SPSR


  AND r1, r1, #0x1f


  BL Undef_Handler


   


  5.     D-ABT 핸들러도 설계해보자.


  HandlerDabort:


  SUB r0, lr, #8


  MRS r1, SPSR


  AND r1, r1, #0x1f


  BL Dabort_Handler


   


  3) Unaligned Access


  1.     v5부터 지원하지만 완전하지 않고 제약이 많다.


  2.     Multiple access 명령 (LDRD, STRD, LDM, STM, PUSH,
  POP)은 무조건 4B align된 주소에서만 동작한다.


  3.     CP15.C1àSCR.A = 1 (unaligned 금지)


  4.     SCR.A = 0 (unaligned 허용)


   


  4) 복귀형 핸들러
  설계: SVC


  1.     복귀되었을 때 모든 레지스터가 보존되도록 설계해야한다.


  C 핸들러에서 Scratch 레지스터가 훼손됨.


   


  2.     HandlerSVC:


  stmdfd sp!, {r0-r3, r12, lr}


  sub r0, lr, #4


  mrs r1, spsr


  and r1, r1, #0x1f


  bl SVC_Handler


  ldmfd sp!, {r0-r3, r12, pc}^


   


  
 



