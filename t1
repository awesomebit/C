


 
  
  <2부. 고급 포인터 분석 및 설계>


  1과. 배열과 메모리 분석


  1.     포인터끼리 연산은 뺄셈만 가능하고, 둘 주소 사이의
  해당 데이터 Type의 개수를 구할 수 있다.


  2.     Sizeof 연산은 해당 데이터의 Byte 크기를 구한다.


  3.     포인터는 망원경이다: 메모리는 무한하고 포인터는
  항상 4Byte로 생성되는 망원경이다. 포인터는 주소라서 *연산자로 망원경 윈도우에 보이는 데이터를 꺼내볼 수 있다.


  4.     이름으로 주소를 구하려면 &연산자를 사용.


  5.     배열 제 1공식.
  정의식: 배열명은 배열의 첫 요소의 주소다. 


  a ==
  &a[0];


  6.     배열 제 2공식.
  활용식: int a[4] 배열에서 배열명 a는
  주소로 사용될 때 int* 타입이다. 등가포인터.


  a[i]
  == *(a + i);


  7.     p[n] 연산자는 p 주소의 연속한 메모리에서 n번째
  떨어진 데이터를 액세스한다! // *(p + n) 과 동일 연산


  8.     배열 제 3공식.
  특성식: 모든 배열은 배열명과 배열의 주소 값이 같은 특성이 있다.


  a ==
  &a;  // a == &a[0] 라서 가리키는 주소가 같은 것이지 타입이 같은 것은 아니다.
  주의.


  2과. 무한확장 변수의 해석


  1.     Modifier에는 주소, 배열, 함수가 있다.


  * 붙이면 주소화 // [] 붙이면 배열화 // () 붙이면 함수화


  2.     연산자의 우선순위는 단항 > 이항 > 삼항 순.


  연산자 우선순위는 단한우선, 후치우선, 근치우선 규정이다.


  우선순위는 결합순서가 같은 것이지
  실행순서와 같은 것은 아니다.


  3.     변수를 영어로 읽어보자.  Int*(*a[4])(int*)


  a is
  4 array of pointer to function with pointer to integer returning pointer to
  integer.


  a 는 int 포인터를 리턴하고 int 포인터를 받는 함수를 포인트하는 4배열이다.


  4.     불가능한 변수 형태: 함수 리턴이 배열, 함수 리턴이 함수, 배열 요소가 함수.


  5.     *, [ ], ( ) 연산자의 피연산자는 주소 타입이어야 한다.


  
 
 
  
  <2부. 고급 포인터 분석 및 설계>


  3과. 깡통이론과 대치법


  1.     문자열의 Type은 char* 이고 주소타입이다. %s로 문자열의 주소를 읽는 것.


  2.     마찬가지로 배열명, 함수명, 문자열 상수, 포인터 변수는 모두 그 자체로 주소인 Type들이다. 


  3.     이 중에서 포인터 변수만 주소가 변경이 가능한 l-value이고
  배열명, 함수명, 문자열에 접근해 수정하거나 입력하려면 *연산자로 접근해야한다. 배열과 함수 대신해 배열 등가포인터, 함수 등가포인터를 쓴다.


  4.     깡통이론: 무한확장형 변수는 일반 변수와 달리 스스로
  주소화되고 그 안에 데이터를 넣는다. 배열, 함수, 문자열은 그 자체의 깡통을 갖는다.


  5.     배열깡통: 배열은 자기 이름의 깡통을 갖고 그 안에
  배열을 넣는다. 이 깡통의 이름이 배열 a, 그 깡통의
  메모리 주소는 &a가 된다.


  6.     대치법: 동등한 타입이면 서로 대체할 수 있다. 좌변 우변의 Type이 완전히 같아야 사용가능. 하지만 경고/자동형변환,
  void*, &와 sizeof 연산에서는 대치법 사용 불가능. 


  7.     2차원 배열이 메모리는 많이 쓰지만 포인터 배열보다 속도가 빠르다.


  8.     함수깡통: 함수명은 곧 함수 주소다.  // add == &add;  //함수 앞에 붙은 * 은
  전부 가짜다.  


  9.     포인터 깡통: 포인터 깡통은 배열, 문자열, 함수와 달리 가리키는 대상이 깡통이다. 모든 포인터 p가 가리키는 것은 이름이 (*p).


  10.  구조체는 기본형이라서 int type과 비슷하다. 구조체 포인터도 int* 와 비슷하다고 생각하면 됨.


  4과. 배열의 등가포인터와 양파이론


  1.     2차원 배열의 초기화: 배열은 초기화할 때 한하여 요소수의 생략이 가능하다. 


  int
  a[ ];  int a[ ][3]; 


  2.     주소에 +1 을 더하면 자기가 가리키는 Type의 크기만큼 이동한다! 


  3.     2차원 배열 활용식: 
  a[m][n] == *(*(a + m) + n);


  4.     배열 등가 포인터로 불가능한 함수리턴함수, 배열리턴함수, 함수요소배열을 쓸 수 있다. 액세스 가능.


  5.     Void* 는 등가 포인터가 될 수 없다.


  6.     *, [ ] Modifier: 변수 선언시에 주소 다중화.


  7.     *, [ ] 연산자: 수식에서 주소 벗기는 연산.


  8.     & 연산자: 주소를 다중화시키는 연산.


  9.     양파이론: *, [ ] Modifier 와 & 연산자는 주소의 겹을 늘리고 *, [ ] 연산자는 주소를
  벗긴다.


  
 
 
  
  <2부. 고급 포인터 분석 및 설계>


  5과. 함수 등가포인터와 직관적 코드 설계


  1.     함수 등가포인터는 함수 이름 대신 (*p)를 넣는다. //배열이나 문자열과 같이 함수의 양면성 때문.


  2.     Int(*p)(int,int); p = add; 선언 가능. 함수는 이름명이 곧 주소라서 굳이 p = &add; 로 선언하지 않아도 옳다. 대치법 적용
  가능.


  3.     함수 등가포인터는 p() 로 실행한다.


  4.     Parameter 미지정형 int(*p)(); 를 쓸 수 있다. 이
  경우 인자 타입과 개수 관계없이 인자로 받을 수 있다.


  5.     Switch문이나 if~else문에 비해 함수 등가포인터를 사용해 함수에 접근하면 훨씬 효율적이고
  빠른 코드를 짤 수 있다.


  6.     함수의 타입은 항상 *포인터로 주소화해서 쓰자.


  7.     Call back 함수: 함수를 호출하면서 함수를 전달하는 함수.


  8.     Typedef를 사용해 타입캐스팅을 더 효율적으로 할 수 있다. 잘 쓰려면 가장 마지막에 가리키는
  변수, 배열, 함수, 문자열
  등의 타입을 먼저 정의하고 그 타입의 주소 또는 등가포인터를 만드는 식으로 typedef를 선언하면
  편하다. //무한확장형 typedef //직관적 코드
  설계 예제 풀기


  6과. 힙과 메모리 직접 액세스


  1.     동적 배열: int* p = malloc(x*sizeof(int));


  2.     동적 배열을 그대로 쓰면 p[0][4] = p[1][0]와
  같은 일반적인 배열의 환산법이 안된다. 순차적으로 저장되지 않기 때문.


  3.     선형메모리에 할당해야 일반적인 배열처럼 쓸 수 있다.


  4.     Ex) int(*p)[4];
  p=malloc(3*sizeof(int[4])); //int[3][4]배열 만들기


  5.     등가포인터만 잘 활용하면 동적 배열을 만들 수 있다.


  6.     모든 요소수가 가변인 배열: int a[m][n];
  int** p = malloc(m*sizeof(int*)); int* p = malloc(m*n*sizeof(int));


  7.     Heap 동적 배열에 a[1][2][3]의 내용을 찍으려면,
  p[1*y*z + 2*z + 3];


  8.     메모리에 값 대입: *(int*)0x1000 = 100;
  //주소에 타입캐스팅


  7과. Type Qualifier


  1.     Const 타입은 가리키는 타입을 read-only로 만든다. 원본을
  보호할 때 사용.


  2.     Lookup table: 값을 읽기(참조)만
  하고 변경할 일이 없는 배열.


  8과. 고급 포인터 타입 캐스팅


  1.     Type Casting에서 대치법을 사용하기 위해 좌변과 우변의 Type을 동일하게 맞추는 것이 중요하다.


  2.     *Modifier는 가리키는 변수타입의 주소타입를 만든다. *연산자는 그 주소타입이 가리키는 변수타입을
  가져온다. *(별)이
  Modifier로 작동할 때와 연산자로 작동할 때 차이를 분명히 구분하기.


  3.     & 연산자는 연산하는 변수타입의 주소를 가져온다.


  4.     바라보는 변수타입이 주소타입이라면 *연산자로 내용물을
  가져오자.


  5.     함수의 요소가 &p 와 같이 주소로 들어오면
  대치법으로 *Modifier를 붙여서 타입캐스팅해준다.


  6.     Printf 함수는 첫번째 인자만 문자열배열이고 나머지는 가변인자라 무엇이 몇 개이든지 들어와도 상관없다.


  7.     가변인자가 들어오면 함수는 그 개수만큼 스택을 쌓는다. 가장
  먼저 들어오는 인자가 스택의 상위에 위치. 스택의 상위가 낮은 주소임.


  8.     가변인자에 액세스 방법은 //1) 첫번째 인자의
  주소를 구한다 &a  //2) 그
  다음 인자의 주소는 a의 타입의 크기만큼 더해서 구한다. Int
  type 이라면 (&a+1) 
  //3)두번째 인자에 접근하려면 *(&a+1)  //3) 만약 a가 char 타입이라면 *(&a+4)임에 주의.


  9.     실수는 %f 로
  print할 수 있다. 정수는 %x(16진수), %d


  10.  “%#.8x” 로 16진수 0x00000000을 찍자.


  11.  간이 format 지시자로 switch문을 대신할 수 있다. 메모리에 바로 접근하기 때문에
  더 빠르고 고급스럽다.


  12.  중요한 것은 함수에서 인자의 타입이 무엇인지이다. 함수, 배열, 문자열의 이름이 들어온다면 해당 타입으로 타입캐스팅하고 *연산자로 내용에 접근하자. 만약 &a처럼 이름의 주소가 들어오면 *Modifier로 주소를
  타입캐스팅하자.


  
 
 
  
  <1부. C문법 재정립>


  1과. 데이터 타입과 형변환


  1.     기본형: 정수인 경우 signed int, 실수인 경우 double


  2.     Little endian: 작은자리수가 낮은 주소에 저장됨.


  3.     음수표현법: Signed magnitude, 1의보수법, 2의보수법.


  4.     2의 보수법이 표준. 작은 주소부터 큰 주소까지에서 첫번째 1값 bit 이후 모든 bit를
  반전한다. (sign이 음수표현인 1인 경우)


  5.     Signed int si = -1; (0xffffffff)


  6.     %d 는 signed int, %u 는 unsigned
  int, %x 는 16진수 값(메모리에 저장된
  값 그 자체)


  7.     Embedded compiler 대부분은 unsigned int가 기본형이지만 비주얼
  스튜디오는 signed int가 기본형.


  8.     Sizeof(a) / sizeof(a[0]) 는 배열의 요소수 계산.


  9.     형변환!! //연산시 큰 타입, 대입시 좌변, 호출시
  parameter 목적지, casting시에 강제로
  type이 형변환된다.


  10.  데이터 타입 크기비교: 정수의 왕은 signed int, 하지만 signed int < unsigned
  int, // int < long int < long long int < float < double < long
  double // 실수가 정수보다 크다 // char, short 같이 작은 정수 타입은 signed int로 형변환된다.


  11.  SRC에서 작은 DST로 변환시, truncation으로 DST에 데이터가 짤려들어간다. 


  12.  작은 SRC에서 큰 DST로 변환시, signed type 이면 DST의 나머지 메모리 공간에 부호가 채워진다! 음수라면 1로 전부 채워지는 점에 주의. (signed char src 에서 int dst 로 변환되는 경우와 같이)


  13.  실수에서 음수값은 signed magnitude 방식
  사용. 가장 큰 bit 값에 음수면 1을 저장한다 (부호 SIGN)


  14.  정수에서 음수값은 2의 보수법. 다르다.


  15.  부동소수점(float point) 방식으로 실수
  표현한다.


  16.  Float 타입의 경우 부호(1),지수부(8),가수부(32) bit 사용. //EXCESS-127 CODE 꼭 찍어주자.


  17.  Double 타입의 경우 EXCESS-1023 CODE 찍는다.


  52bit
  메모리 사용.


  18.  Float은 메모리를 아끼지만 오차 때문에 부정확하다. 정확한 값을 따지려면 Double 실수타입을 쓰자.


  19.  bit연산할 땐 unsigned 타입을 쓰자.


  20.  Signed int 타입의 경우 부호(최상위비트)가 1이면 shift연산으로 좌측이동시켜도 부호자리는 항상 1이 copy된다. (우측이동은
  괜찮다) //따라서 signed int 타입을 bit shift연산 하고 싶으면 (unsigned int) 타입캐스팅해서
  쓰자. 마찬가지로 signed char, signed short도 signed int로 자동 형변환되므로 주의.


  21.  전역변수와 지역변수. 스택의 운용. 


  22.  Extern 변수 선언해서 외부 변수를 호출하려면 해당 외부파일에서 변수가 static으로 선언되면
  안된다.


  
 



