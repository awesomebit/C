


 
  
  1) Java란?


  1.     Java는 썬마이크로시스템즈에서 임베디드 가전제품에 소프트웨어를 올리기 위해 개발함. Green
  Project


  2.     JDK는 플랫폼에 따라 다른 버전을 받아야 함.


  3.     JDK는 플랫폼 종속적. (개발환경IDE에 따라
  다른 버전을 다운로드해서 개발해야 함)


  4.     JAVA는 플랫폼 독립적. (JAVA로 개발된 프로그램은 운영체제에 관계없이 작동)


  5.     변수는 ‘_’, ‘&’ 특수문자만 사용 가능.


  2) JAVA DEVELOPMENT TOOL KIT (JDK)


  6.     JDK8.0을 설치하자. Jdk8.0 doc도 필요함 (부품
  설명서)


  7.     JDK8.0의 bin 파일을 시스템 환경변수 PATH에
  등록해주자.


  8.     프로그램을 개발할 때, JDK에 있는 ‘부품’들을 사용해서 개발하거나 없는 ‘부품’은 직접 코딩해서 쓸 수 있다. 결국 자바프로그램은 이런 ‘부품’들의 조합임.


  9.     JRE(Java Runtime Environment): JVM(Java
  Virtual Machine) + API(Application Program Interface) 자바 프로그램을 실행할 때 필요한 환경. 예를 들어
  나는 자바개발을 안하는데 웹사이트에서 자바프로그램을 사용하면 내 컴퓨터에 JRE가 설치된다.


  10.  JDK(Java Development Toolkit): Compiler를 비롯한 개발에 필요한 여러도구 + JRE


  3) JAVA 프로그램 실행 프로세스


  1.     HelloWorld.java (source code) ->
  HelloWorld.class (byte code) -> JVM (Java Virtual Machine), Platform (OS,
  HW, Resources)


  2.     자바에서 실행파일은 .class 파일이다.


  Javac(compiler)가 .java 소스코드를 .class 바이트 코드로 바꿔주면 JAVA가 .class 파일을 실행한다.


  이 .class 파일은 JVM이 실행시켜주는데, JVM은 여러 플랫폼 (OS, HW, Resources 등)과 호환된다. 따라서 JAVA는
  플랫폼 독립적이라는 것.


  3.     .class 파일은 JVM과만 만나기 때문에 플랫폼이 무엇이든지 상관없다. 하지만 JVM에서 돌고 플랫폼 위에서 JVM이 또 돌기 때문에 속도가 C언어보다 느리다. C는 플랫폼 종속적이라서 플랫폼에 딱 맞는 코드로 작성돼있다.


  4.     Class == object == 부품 == component


  4) JAVA 프로그래밍


  1.     System.out.println(“Hello World”); //표준출력(console에)


  2.     자바는 대소문자 구분함.


  3.     <cmd창 명령어>


  C:\javawork>
  javac HelloWorld.java (컴파일 명령)


  C:\javawork>
  javac *.java (모든 파일 컴파일 명령 -> .class 실행파일 생성함.)


  C:\javawork>  java HelloWorld (.class 파일 실행 명령)


  5) 변수와 데이터형


  4.     true, false, null 은 예약어로 값이 이미 정해져있기 때문에 식별자로 쓸 수 없다.


  5.     JAVA에서 char type 은 2Byte. byte
  type 이 1Byte. (자바는 유니코드이기 때문)


  6.     정수는 연산할 때 데이터 타입을 맞춰야 하고, 실수는
  변수에 값을 저장할 때부터 데이터 타입을 고려한다. 예를 들면
  1.2 라는 값은 자바에서 8B 공간을 주는데, 그냥 float type (4B)에 저장하려고 하면 에러. // float f
  = 1.2f 로 저장한다.


  7.     If~else문, switch~case문(long type을
  제외한 정수형만 요소로 쓸 수 있음. Float, double 실수타입도 불가능),


  8.     For문, while문, continue제어, break제어,


  9.     Array: 동일 타입의 데이터 여러 개를 저장하는 자료구조


  배열 같은 ‘참조형’과 정수타입 같은 ‘기본형’의 차이는 참조형은 타입선언 후 생성을 꼭 해야한다는 점.


  Int[]
  data; // ( = int data[]; ) // 배열의 선언


  data
  = new int[3]; // 참조형은 꼭꼭! 생성해야한다!


  data[0]
  = 100;


  10.  자바에서 배열을 생성하면 기본값이 존재함. 그냥
  기본형은 기본값 없음.


  Int형 배열 -> 0 // double형 배열 -> 0.0 


  // Boolean형 배열 -> false


  
 
 
  
  1) JAVA 메소드


  1.     getLabel() 같이 get으로 시작하는 메소드는 값을 리턴해줌 


  (Getter)


  2.     setLabel() 같이 set으로 시작하는 메소드는 값을 저장함 

  (Setter)


  3.     JDK docs index.html에서 메소드 목록을 검색해서 활용하자.


  2) JAVA class 와 object


  1.     CLASS: data + method로 이루어진 구조. 템플릿과 같음 (붕어빵을 찍어내는 틀). JDK에 들어있는 것이 이 class들


  2.     OBJECT: class로부터 생성된 실체. 키워드 new로 객체 생성. (붕어빵 틀로부터 만들어진 빵)


  3.     class Test{}  // 1. 클래스 설계


  Test
  t = new Test();  // 2. 객체 생성


  t.go();  // 3. 객체 사용


  4.     CONSTRUCTOR(생성자): 클래스 이름과 동일한 이름의 함수, 리턴타입을
  적지 않음. 객체의 생성시에 자동으로 호출됨.


  5.     생성자는 생성할 때 자동으로 호출되기 때문에, 생성시에
  필요한 작업은 생성자 안에 담는다. Test(){} //default 생성자


  6.     JVM에서 class는 설계한 순간 한 공간을 차지하고, 클래스를
  사용해 객체를 생성하면 (Test t = new Test();) Heap메모리 공간에 객체가 만들어진다. JVM 내부에서 객체에 Heap 주소값 지정해줌. 객체는 생성할 때 기본값 있음 (int d = 0; String st =
  null; 등). 


  7.     this( ); 메소드는 생성자 안에서만 사용할 수 있고, 생성자 안에서 다른 생성자를 호출할 때 쓴다.


  8.     메소드 오버로딩: 한 클래스 안에서 똑같은 이름의 메소드를 여러 번 정의해 놓는 것. 각각의 메소드는 parameter 리스트로 구분함.


  public
  void go(){ … };


  public
  void go(int a){ … }  // go 메소드가 오버로딩 된 상태


  3) JAVA의 특징


  1.     <상속>: 기존 클래스의 내용을 바탕으로 새로운 클래스 설계


  class
  Child extends Parent{ }  // 한 부모로부터만 상속 가능


  2.     상속받은 자식이 만들어지면 (Child c = new Child();)
  Parent가 Heap memory에 먼저 저장된다.


  3.     오버라이딩은 리턴타입, 타입, 메소드명 변경 불가


  4.     super은 부모를 호출하는 메소드. Ex) super.getName();


  5.     super, this 메소드는 static 메소드 안에서 사용 불가


  6.     모든 클래스는 public class Object 라는 Object 클래스를 superclass (부모 클래스)로 가지고 있다. Class Object is the root of all
  class hierarchy. All objects including arrays implement the methods of this
  class.


  7.     하나의 파일에 public class 는 단 한
  개만 쓸 수 있고 그 class의 이름이 파일의 이름이어야 한다!


  8.     우클릭 -> Source 에서 Override, Generate Constructor


  9.     자식의 생성자에서 필드에 값을 직접 input을
  넣을 수는 없고, super 메소드를 사용해서 부모의 생성자를 통해 간접적으로 값을 입력해야 한다. (부모의 생성자가 해당 parameter를 지원한다면)


  10.  무엇이 에러인가?


  Parent
  x = new Child();


  Child
  x = new Parent();  <- ERROR!


  //
  new Parent()는
  Parent 사이즈만큼 메모리를 지정해주지만 가리키는 Child x 가 부모보다 더
  크기 때문에 에러!


  11.  Parent x = new Child();  


  Child의 크기만큼 객체가 생성되어서 그 객체 안에서 놀 수 있다.
  자바에서는 객체 개념으로 생각하자. 만들어진 객체 사이즈 이하만큼만 볼 수 있고 (포인트할 수 있고) 그 이상을 가리키는 어떤 객체에 집어 넣으려고
  하면 에러난다.


  12.  부모의 자식의 자식의 자식… 이 있는 경우에 같은
  이름의 메소드가 있으면, 가장 최종적인 자식에서 Overriding
  된 메소드가 호출된다. (super메소드를 사용하지 않는 이상). 


  13.  super 메소드로 부모의 메소드에 접근하면 동일명의 메소드라도 부모의 메소드가 우선 호출된다. this 메소드로
  자기 자신의 동일명의 메소드를 우선 호출할 수 있다.


  14.  하지만 자식에만 있는 메소드는 this(부모위치)에서 호출할 수 없다. 


  15.  Parent x = new Parent(); 가 생성되면 이 객체는 Parent만큼의 사이즈만
  갖고 있기 때문에 자식의 메소드,필드는 볼 수 없다. 따라서
  오버라이딩 유무도 상관없어진다.


  16.  다형성: 같은 객체라도 받는 클래스에 따라 다른
  형태로 해석되는 것. (오버로딩, 오버라이딩)


  
 
 
  
  1) 추상 클래스


  1.     <Abstract>추상 메소드를 포함하는 클래스. 추상 메소드는 함수의 body( { } )가 없는 미완성의 함수


  public
  abstract class MyAbstract{ 


  public abstract void go(String m); }


  2.     미완성의 클래스라서 생성 불가. 다른 클래스에서
  추상 클래스를 상속해서 완성(구현)해줘야 함.


  public
  class Complete extends MyAbstract{


  public void go (String m){ } } 


  //({ }) body를 포함한 완성함수


  3.     Main 에서 추상클래스의 배열을 생성할 수 있다.


  Abstract[]
  abst = new Abstract[3];


  4.     <구현 상속>: 일반 클래스 상속 (완성된
  메소드를 물려줌)


  5.     <타입 상속>: 추상 클래스 상속 (추상
  메소드를 물려줌)


  6.     추상 클래스는 상속받아서 쓰는 용도(같은 타입의
  클래스로 묶는 용도, 같은 메소드로 통일)지, 굳이 생성할 수도 없고 생성할 필요도 없다.


  7.     <Interface>: 클래스 안의 모든 메소드가 추상 메소드인 미완성의 클래스. 


  interface
  MyInterface{


  public void go(); }  


  //abstract과 public은 메소드에 쓰지 않아도 Interface 안의 메소드는 모두 추상메소드로 인식한다.


  public
  class Complete implements MyInterface {


  public void go() }


               //
  implements 로 상속받는다. (다중 상속 지원)


  8.     추상클래스, 인터페이스 동시에 상속받기:


  public
  class Test extends Abst implents Inter, Inter_ { }


  상속받은 자식은 Interface 부모의 메소드를 무조건 완성시켜줘야 한다.


  9.     인터페이스로 다중상속이 가능한데, 기존에 존재하는
  부모자식 관계에서 그 관계를 유지시키면서 따로 그룹핑이 필요한 경우에 사용할 수 있다.


  10.  instanceof 는 상속관계 여부를 Boolean 타입으로 리턴한다.


  자녀 instanceof 부모 à TRUE


  부모 instanceof 자녀 à FALSE


  객체 instanceof 객체 à TRUE


  11.  interface type에 접근하려면 this, super이 아니라 인터페이스명으로
  접근해야 함


  12.  인터페이스 안에 필드 타입은 수정 불가. int 로
  선언해도 static final int로 선언되는 것.


  13.  인터페이스 간에 상속도 가능.


  14.  final: 멤버필드(값 변경 불가), 메소드(오버라이딩 불가), 클래스(상속
  불가).


  15.  static: 객체들 간에 공유되는 유일한 값 – 멤버필드, 메소드, 블록( {} )


  static
  블록!!! 쓸 수 있다.


  변수 명이 Italic체면 static 임.


  Static
  변수를 사용할 때는 객체 생성 후 사용하지 않고 클래스에서 사용할 수 있다. (클래스명.변수명)으로
  콜


  public
  class StaticTest{ 


  static int scount = 0;


  public static void main(String[] args) {


   
  System.out.println(++StaticTest.scount);


  }


               }


               //
  원래 변수는 객체 생성 (StaticTest
  st = new StaticTest(); )              후에 st.scount 이런식으로 써야 하지만 static 변수는 예외.


  16.  Static 블록:  main() 앞
  뒤로 쓸 수 있다. static { } 로 쓴다. Main() 실행되기
  전에 앞 뒤 상관없이 static 블록부터 무조건 실행된다.


  2) 자바 프로그래밍
  – 패키지


  1.    다른 패키지에 있는 클래스를 호출해서 쓰려면, 


  import
  com.korea.seoul.Tommy; 


  (패키지명이 com.korea.seoul)


  2.    이클립스에서 ctrl + shift + o 단축키를
  누르면 필요한 클래스를 자동으로 import 함.


  3.    Import java.awt.* 으로 모든 클래스 호출할 수 있지만, 메모리를 너무
  많이 잡아먹는 문제 있음.


  4.    Java.lang은 무조건 import됨


  5.    같은 패키지 안에 있으면 private type을
  제외한 나머지 (protected, public, default)를 호출할 수 있다. Private에 접근하면 not visible 에러. 부모의 private type에도 접근 불가.


  6.    Private type은 같은 클래스 안에서만 쓸 수 있다.


  7.    다른 패키지에 접근할 수 있는 type은 public 뿐. 만약에 부모자식으로 클래스가 연결돼있으면 다른
  패키지라도 protected type은 호출 가능. 다른
  패키지면 default type은 이래나 저래나 호출 안됨.


  3) 클래스 다이어그램 (UML 표기법).. unified model language


               <접근제어자>


  1.    ( + ) : public


  2.    ( - ) : private


  3.    ( # ) : protected


  4.    없으면 default


  4) 메소드 추가


  1.     생성자 대신 setNum(int n) 메소드로 필드
  입력하는 이유는 메소드 안에 체크할 수 있는 코드를 더 넣을 수 있기 때문 (if ~ else문
  등)


  2.     @Overriding 하는 메소드는 부모 메소드의 접근지정자보다 크거나 같은 접근지정자로 ‘수정’할 수 있지만, 더 좁은 접근지정자로 수정할 수는 없다.


  < JCF(Java Collection Framework) >


  LIST:


  5) Vector


  1.     Import.java.util.Vector


  2.     Vertor() 생성자의 초기값은 10배열을 준다.


  3.     Vector(int initialCapacity, int
  capacityIncrement) 지정 가능


  4.     capacityIncrement가 없으면 데이터 공간이 부족할 때마다
  initialCapacity의 2배씩 늘어난다.


  5.     Vector<String> v2 = new
  Vector<>();  //Vector에 String type만 저장할 수 있도록 지정.


  6) ArrayList


  1.     ArrayList<Circle> list2 = new
  ArrayList<>();


  list2.add(new
  Circle(2));


  
 
 
  
  1)  Hash Set


  1.     HashSet은 중복 데이터를 입력받지않고 입력받은 순서대로 저장하지 않는다. 따라서 출력 순서도
  뒤죽박죽임.


  2)  Hash Map


  2.     HashMap<String, String> map = new
  Hashmap<>();


  3.     map.put(“num”,”123”);  // .put( key, value ) 으로 저장.


  같은 key 에 중복 저장되면 마지막 value로 덮어씌여진다.


  4.     String value = map.get(“num”);  // .get( key )로 꺼낼 수 있다


  5.     Set<String> keys =
  map.keySet();  


  // .keySet( ) 은 HashMap의 key값만 Set으로 리턴한다. Set이기 때문에 Loop로 출력 가능.


  3)  String


  1.     String s = “mylimeorange”;  // 원래
  String 같은 reference 타입은 String s = new String(“mylimeorange”); 로 생성해야 하지만, String은 예외적으로 기본형처럼 선언 및 생성할 수 있기 때문에 오류가 아니다.


  2.     String type을 가진 a 와 b 를 직접적으로 비교하면 (a == b) String 은 reference 타입이라서 주소를
  비교한다.


  String
  a = “orange”; 


  String
  b = new String(“orange”); 


  String
  c = “orange”;


  이 경우 (a == b) == FALSE;  (a == c) == TRUE;


  3.     String type의 내용을 비교하려면, a.equals(b) 메소드 써야함


  4.     s.concat(“hello”);  // s 뒤에 “hello”를
  결합


  5.     s.toUpperCase();  // s를 대문자로 변경


  6.     s.toLowerCase();  // s를 소문자로 변경


  7.     이런 String 메소드는 원본은 그대로 두고 새로운
  메모리 공간에 새로운 값을 만든다. (공간을 많이 잡아먹음)


  8.     따라서 k = s.concat(“hello”); 처럼 k에 저장한 뒤 k를 출력해야 새로운 값인 mylimeorangehello를 가져올 수 있다. 그냥 s 를 가져오면 원본인 mylimeorange만 가져옴.


  9.     s.substring(2,6) 메소드는 String에서 2번째 문자부터 5번째까지 가져온다. (주의: 6번째는 안가져옴,
  2이상 6미만)


  10.  s.indexOf(“l”); 메소드는 중복되는 문자가 있는 경우, 가장 앞 쪽의
  문자의 인덱스를 가져옴.


  4) StringBuffer


  1.     String과 달리 원본을 수정할 수 있다.


  2.     StringBuffer buffer = new StringBuffer(“mylimeorange”);


  3.     buffer.append(“hello”); 메소드로 원본에 더할 수 있다.


  출력하면 mylimeorangehello. 원본이 바뀜


  4.     buffer.insert(0, ‘b’); 메소드는 bmylimeorange


  5.     메모리 낭비가 없다.


  5) Generic Programming


  1.     설계하는 클래스의 데이터 타입을 compile time에
  고정하지 않고 runtime 시까지 미뤄서 하나의 값이 다양한 타입을 가질 수 있도록 하는 기법


  public class MyObject<X> {


      private X value;


      public X getValue(){


          return value;


      }


      public void setValue(X value){


            this.value = value;


       }


       public static void main(String[] args){


            MyObject<String> m1 = new MyObject<>();


            m1.setValue(“m1은 String”);


  MyObject<Integer>
  m2 = new MyObject<>();


          
  m2.setValue(new Integer(111));


            // 이런식으로 여러 개 타입으로 지정 가능.


  }


  6) Wrapper 클래스


  1.     기본형을 참조형으로 바꾸는 방법


  int
  count = 300;  // 기본형


  Integer
  I = new Integer(count);  // 참조형(객체형) 변환


  2.     String[] str = “123”


  int
  num = Integer.parseInt(str[0]);  


  //
  String형에서 int
  형으로 저장.  num은 1


  7) Exception / Error


  1.     Error: 복구 불가능한 문제 상황


  StackOverFlowError,
  NoSuchMethodError


  2.     Exception: 복구 가능한 문제 상황


  RuntimeException:
  실행은 됨 


  Non-RuntimeException:
  실행 안됨, 컴파일도 안됨


  3.     Exception Handling


  1       예외가 발생한 곳에서 직접 처리


  try~catch~finally


  2       호출자로 보내서 예외처리 위임


  throws
  


  4.     Exception도 클래스임


  try
  { (Exception 발생하는 메소드 등) }


  catch(ArithmeticException
  q) {  …   } 


  finally
  { … }


  5.     catch()는 여러 번 쓸 수 있는데 (Exception q)를 인자로 받으면 모든 Exception을 catch할 수 있다.


  q.getClass().getName()
  으로 Exception의 이름도 가져올
  수 있다.


  6.    
  Thread.sleep(3000); 처럼 try~catch를 반드시 해야하는 NonRuntimeException도
  있음


  7.    
  new ExceptionTest().first(1);  //이렇게 하면 객체 생성 후 바로 메소드를 호출하는데, 1회용 호출임


  8.    
  throw new Exception(): 메소드 안에서 Exception이 발생하면 상위로 책임을 던짐. à 마지막에 받은 곳에서 try~catch() 로 처리.


  
 
 
  
  1) Thread


  1.     프로세스 내의 개별적인 실행 흐름


  2.     프로세스는 프로그램 실행에 필요한 자원과 쓰레드로 구성


  3.     모든
  프로세서는 최소 하나 이상의 thread가 존재해야 실행가능


  4.     multithread: 둘 이상의 쓰레드를 이용한 프로그램. CPU, 자원이용률을
  높임. 사용자 응답성이 향상됨(응답속도가 빠름)


  5.     프로그램이
  클라이언트 단위로 들어왔을 때 프로세스 단위보다 쓰레드단위로 처리를 하면 더 효율적이다.


  6.     Thread 작업 시작을 위해선 반드시 start 메소드를 실행시켜야
  함.


  7.     Thread 는 FIFO


  8.     Thread 생성방식


  1)    Thread class 상속


  2)    Runnable interface 구현


  3)    두 방법 모드 run() 구현해야 함. (thread 작업내용 기술)


  9.     Thread가 start() 메소드를 호출하면 알아서 run() 메소드를
  호출해서 실행한다. à run() 메소드는 callback 메소드.


  10.  callback 메소드: 직접 호출되지는 않지만 특정 조건이 되면
  실행되는 메소드


  11.  <Thread 상속받아서 쓰레드를 만드는 방법> 


  <사용자정의 쓰레드>


  class Tiger extends Thread { } à 여기서 run() override


  …main 에서,


  Tiger
  t1 = new Tiger();


  t1.start();


  12.  <Runnable로 쓰레드를 만드는 방법>


  1)     class Lion implements Runnable { }


  2)     Runnable에서 정의한 run(); 이라는 추상메소드를 Thread 클래스에서 run(){}처럼 body부분를 내용없이 override하였다. (빈 껍데기의 run 메소드를 물려줌)


  3)     Lion 클래스는 run()을
  override.


  4)     Lion l1 = new Lion();


  Thread
  t1 = new Thread(l1); 


  t1.start();
   à l1의 run()을 찾아가서 실행시킴.


  5)     생성자 안에서 run()을 만들어주자


  public
  Lion() {


      Thread t = new
  Thread(this);


      t.start();


  }


  13.  사용자정의 쓰레드보다 main 쓰레드의 우선순위가
  높다!


  14.  t.join(); 


  à t 쓰레드가 일을 전부 마칠 때까지 다른 쓰레드들은 기다리도록 만드는 메소드. 


  à main 쓰레드보다 우선순위가 높아진다.


  try{


               m.join();


  }catch(Exception e){


               e.printStackTrace();


  }


  15.  Thread Synchronization: 다수의 thread가 공유 데이터에 접근해서 작업할 경우 thread간 간섭 현상이 발생


  이를 방지하기 위해 thread 간에 동기화를 시켜 줌.


  è  메소드에 lock 걸기


  public
  synchronized void add() { }  


  //동시실행이 아니라 순차실행이라서 실행속도는 떨어짐


  synchronized를 붙이면 이 메소드가 호출 중에는 다른 객체가 접근 못한다.
  


  Run()
  은 synchronized 붙이지
  않고 쓰자.


  16.  Vector<> 타입은 이 synchronized 기능이 구현되어있다.


  처음부터 이렇게 lock이 걸려있어서 속도 면에서 ArrayList보다 느리다. ArrayList는 synchronized 기능이 없어서 필요에
  따라 쓸 수도, 안 쓸 수도 있어서 속도도 빠르고 더 유연하고 좋다.


   


  2) Stream


  1.     데이터의 input output 주고받는 프로세스의
  중간다리 역할.


  2.     단방향의 스트림만 존재. Input Output을
  받으려면 각각의 스트림이 필요하다.


  3.     Pipe 같은 개녕.


  4.     Process Stream (단독사용은 불가, Node Stream에
  사용가능)


  5.     File tmpFile =
  File.createTempFile("sample", ".txt");


  FileWriter
  fw = new FileWriter(tmpFile);      //node
  stream


  BufferedWriter
  bw = new BufferedWriter(fw);         //filter
  stream


  //
  BufferedWriter 은 한 번에 많은 용량의 데이터를
  쓸 수 있음. 작업할 땐 이런 filter stream을
  사용하자. Reader의 경우도 마찬가지


  6.     Filter를 쓰는 이유는 또, Reader 에서 줄 단위로 읽을 수 있다. (BufferedReader) 는 이런 쓸모있는 메소드를 제공함.


  
 



