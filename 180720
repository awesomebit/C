<복습>
1) 부팅
1. WDT disable
(Memory Mapped I/O)
*(volatile int*)0x100=0;
//volatile 을 붙이는 이유는 컴파일러가 최적화하면서 필요하지 않은 코드 영역을 스킵하는 부분을 막기 위함.
2. LED ON (GPIO)
3. I-cache, 분기예측기 ON  부팅과정을 빠르게 하기 위함.
//부트로더는 FLASH 에서 필요한 파일을 올리고 권한을 넘기기 위해서 존재함.
//초기화 작업을 어셈으로 하기.
 
--------------------------------------------------------------------------------
4. CRT (C runtime startup)
실행파일과 나머지 파일 구분하자.
5. C의 memory
Memory Mapped I/O 영역  volatile
MMU 설정  Code 설정
개발자가 C 환경에서 프로그램을 개발할 수 있도록 하기.

2) 어셈블리 명령어
1. add, adc(add with carry), sub, sub(subtract with carry), rsb, rsc
2. ldr, str
3. b(bx), bl(blx)
4. mov, mvn
5. cmp, cmn, tst, teq
6. and, orr, eor, bic
7. ror, rox
8. NZCV:
[MI,PL], [EQ,NE], [VS,VC]
9. > GT, >= GE, < LT, <= LE

 

<2부> Exception Handling
<1과. AAPCS와 C-ASM 인터페이스>
1) Calling Convention
1. __cdecl
C표준.
장점: 가변인자 전달 가능.

2. __stdcall
장점: C콜은 함수 호출 시 마다 스택을 정리하는 명령이 있지만, stdcall 은 맨 마지막에 스택을 정리하기 때문에 조금 더 효율적.
단점: 가변인자 전달이 불가능.

3. __fastcall
ARM은 fastcall과 cdecl을 섞어쓰는 방식. 스택정리 책임은 caller가. 사용 메모리는 레지스터. 인수 전달 위치는 우측부터 높은 주소.

2) Subroutine 호출과 복귀 명령
1. 기존 MOV PC 를 BX LR 명령으로 바꿔주자 (v5 이후)
2. 함수가 끝날 땐 항상 BX LR (리턴명령)이 있어야 함.
3. LR (Link Reg.) 에 BL 명령으로 복귀주소를 저장함.

3) ARM-Thumb Interworking
1. Thumb 모드 (16 bit), ARM 모드 (32 bit)
2. ARM 모드와 Thumb 모드를 왔다갔다하면서 동작할 수 있다. 이 경우에 전환 시 ‘BL’ 명령을 통해서 전환할 수 있는데, ‘BL’ 명령은 함수 호출시에 ‘LR[0]’ 에 당시 명령체계를 저장한다.
3. ‘BLX’는 T 비트를 무조건 반전시키고 ‘LR[0]’ 를 사용 안함.
4. CPSR의 T 비트: 1Thumb, 0ARM

5. 함수 호출시 명령체계 context 보존과 복원:
이 부분의 처리가 없다면 ASM 파일에서 C파일을 호출하면 LR안에서 계속 맴돈다.  스택으로 처리해주자.

str lr, [sp, #-4]!   ;;LR을 스택에 대피시킨다.
bl c_func
ldr r, [sp], #4     ;;명령 체계간 interworking이 가능한 리턴

4) FD stack (Full-Descending Stack)
1. PUSH 할 때 주소가 감소하는 것.
2. SP 는 TOP data 값을 가르킴. EMPTY는 0

5) AAPCS
1. ARM에서 함수를 호출할 때 argument를 주고받는 데 약속한 레지스터 값.
2. r0~r4, r12 : Scratch Register. 함수를 호출할 대 훼손될 수 있는, 훼손되어도 되는 레지스터.
3. r4~r11 : 호출된 함수로 되돌아가기 위해 LR을 대피시키는 레지스터.
4. 4B 이하 데이터는 4B로 확장된다.
5. 실수는 VFP 사용시 VFP 레지스터로 리턴된다.
6. 구조체, 공용체 등은 4B 이하 데이터는 4B 쓰레기값으로 패딩돼서 확장된다.
7. 4B 초과 구조체, 공용체에서 caller는 4B 초과 데이터 리턴이 필요한 경우 복사받을 주소값을 R0에 전달한다.
8. Stack을 통한 argument 전달 시, 함수 시작시에 SP는 반드시 8Byte align 상태여야 함.

9. 비효율적인 레지스터의 사용 예시

[1] void f(int, double, int); 
   Int  R0 / double  R3, R2 / int  stack
   R4를 쓰지 않고 마지막 인자가 stack에 저장됨.
[2] struct st func(double, int);
   struct st x = func(…);
   x의 주소  R0 / double  R3,R2 / int  stack
   x의 주소가 R0에 저장되기 때문에 마지막 인자가 stack에 저장됨.

6) 다중 메모리 이동 명령: LDM, STM
1. LDM (Load Multiple), STM(Store Multiple)
LDMDB r1, {r1-r4, r12, LR}
, 로 나열 //  - 로 범위 지정
‘DB’ 조건부 명령 실행 가능

2. IA, IB, DA, DB
IA  increment after
IB  increment before
DA  decrement after
DB  decrement before

3. 레지스터는 반드시 낮은 주소에 낮은 레지스터 번호가 저장된다!

4. STM, LDM의 특성
Base Register: STM,LDM 수행 뒤에도 항상 고정
! option: auto-update. 모드에 따라 증가/감소된 값 유지

5. STMFD, LDMFD 는 FD stack을 위한 PUSH POP!
PUSH, POP 명령을 그대로 써도 된다 (v5 이후) 
 ^ 옵션은 불가


7) Scratch Reg. 보존, 복구, 스택정리
1. 실습
Asm_Add_Sqr:
push {r4-r6, lr}  //8Byte align, r6는 dummy reg.
mov r5, r1  //r1 보존
bl Sqr
mov r4, r0  //a^2 보존
mov r0, r1  //b를 전달
bl Sqr
add r0, r0, r4  //a^2 와 b^2 의 합 전달
pop {r4-r6, pc} 
인자로 들어온 r0, r1 모두 보존해야 함.
8) LDR, STR 명령 형변환
1. LDRB: unsigned byte 로딩
2. LDRSB: signed byte 로딩
3. LDRH: unsigned short 로딩
4. LDRSH: signed short 로딩
9) LDRD, STRD
1. (Rn+1, Rn)에 데이터를 저장 (Dual Load)
2. 제약:
Rn+1, Rn 은 연속한 레지스터
Rn은 반드시 짝수번호 레지스터
메모리 주소는 반드시 4배수
Shift 옵션 사용 불가.
10) UXT, SXT 명령
1. char, short를 쉽게 unsigned int로 승격시킬 수 있다.
<2과. Mode와 Exception>
1) Normal 상태
1. F-D-E-F-D-,,, 동작이 정상적으로 작동함.
2. Fetch, Decode, Execute 를 지속하지 못할 땐 Exception 발생!
2) Exception 발생
1. Mode 변경
2. Code 작동
3) 8 Processor Modes
1. User
----------------------------------------------밑은 Privileged Modes
2. System
3. Superviosr
4. FIQ
5. IRQ
-------------------------------밑은 오류
6. Abort
7. Undefined
8. Monitor
4) Exception Vector Base
1. Vectoring: Exception이 발생한 경우 H/W적으로 코드를 변경해준다.
2. Vector Offset에 따라서 해당 코드로 이동한다.
3. 설정:
Vector Base + Offset  PC
Offset은 32bit 테이블이라서 32B Align된 주소로만 설정 가능
 MRC p15, 0, Rx, c12, c0, 0 (
MCR p15, 0, Rx, c12, c0, 0
4. Exception Vector Table
Exception 발생 원인 Vector Offset
Reset 시스템 리셋 0x00
Undefined Instruction 정의되지 않은 명령 수행 0x04
SVC Supervisor call 0x08
SMC Secure monitor call 0x08
BKPT Software breakpoint 0x0C
Prefetch Abort 명령어 fetch 시 메모리 violation 0x0C
Data Abort 데이터 read 시 메모리 violation 0x10
- Reserved 0x14
IRQ Request Normal interrupt 발생 0x18
FIQ Request Fast interrupt 발생 0x1C
5) CPSR, SPSR
1. CPSR: 상태레지스터, SPSR: 상태레지스터 저장용
2. 상태 레지스터 Access 명령:
MRS(상태 레지스터  레지스터), 
MSR(레지스터  상태 레지스터)
CPS (Change Process State) //CPSR 레지스터 필드 수정
3. 현재 설정 유지하고, irq, fiq mask를 disable 하기:
MRS R0, CPSR
ORR R0, R0, #(0x3<<6)
MSR CPSR, R0
또는,
CPSID i
CPSID f
4. Exception으로부터 복귀는 PC와 CPSR가 동시에 복원되어야 한다.
 ^옵션 사용: SPSR이 CPSR에 copy됨.
6) Exception 처리과정
1. 프로그램 수행 중 Exception 발생.
2. SPSR_mode에 CPSR 백업
3. CPSR 수정하고 LR에 되돌아갈 주소 저장(PC - 4)
4. Processor가 H/W적으로 처리함
5. Exception 업무 처리
6. exception handler
복귀: CPSR  SPSR_mode / PC  복귀주소 동시에 동작
7) Exception 종류
1. Undefined Exception
발생원인: 명령 디코딩시 정의되지 않은 명령어
2. Supervisor Call Exception
발생원인: SVC 명령 수행한 경우
3. Prefetch Abort Exception
발생원인: Fetch한 Code 메모리가 invalid한 경우.
4. Data Abort Exception
발생원인: Invalid한 데이터 메모리를 Load 또는 Store한 경우. 문제점 해결 후 복구할 때 PC-8.
5. IRQ Exception
발생원인: 프로세서 외부로부터 IRQ 신호가 인가된 경우.
<3과. Exception Handler 설계>
1) Vector Base 필요성 
1. Exception이 발생하면 Vector Base 가 없는 경우 주소 0x0으로 분기하는데, 0x20000000번지에 프로그램이 다운로드하여 실행된 경우 0x0번지에 아무런 코드가 없어서 문제가 발생함.
2) UND 핸들러
1. main() 함수에서 Exception 발생 (Main.c)
2. Vectorin으로 Undef_Handler로 이동 (crt0.s). undefined mode로 변경됨.
3. Undef_Handler()로 분기해서 무한루프 상태로 전환 (Exception.c).
4. 무한루프 전에 디버깅 정보 출력하기:
HandlerUndef:
SUB r0, lr, #r
MRS r1, SPSR
AND r1, r1, #0x1f
BL Undef_Handler
5. D-ABT 핸들러도 설계해보자.
HandlerDabort:
SUB r0, lr, #8
MRS r1, SPSR
AND r1, r1, #0x1f
BL Dabort_Handler
3) Unaligned Access
1. v5부터 지원하지만 완전하지 않고 제약이 많다.
2. Multiple access 명령 (LDRD, STRD, LDM, STM, PUSH, POP)은 무조건 4B align된 주소에서만 동작한다.
3. CP15.C1SCR.A = 1 (unaligned 금지)
4. SCR.A = 0 (unaligned 허용)
4) 복귀형 핸들러 설계: SVC
1. 복귀되었을 때 모든 레지스터가 보존되도록 설계해야한다.
C 핸들러에서 Scratch 레지스터가 훼손됨.
2. HandlerSVC:
stmdfd sp!, {r0-r3, r12, lr}
sub r0, lr, #4
mrs r1, spsr
and r1, r1, #0x1f
bl SVC_Handler
ldmfd sp!, {r0-r3, r12, pc}^
<Exception 정리>
1) 개념도 정리
 
2) Exception 별 리턴 명령 정리
1. 인지시점이 Decode, 서비스 시점이 Execute인 경우
Exception 표준 리턴 명령
Undefined SUBS PC, LR #4
SVC MOVS PC, LR
BKPT SUBS PC, LR #4
P-Abort SUBS PC, LR #4
2. 인지시점이 Execute, 서비스 시점이 그 이후인 경우
Exception 표준 리턴 명령
D-Abort SUBS PC, LR #8
IRQ SUBS PC, LR #4
FIQ SUBS PC, LR #4
<3과. Exception Handler 설계 (Cont’d)>
5) System Call
 
1. OS와 APP은 별로 컴파일된 실행 파일.
2. OS 계층의 Device Driver를 APP이 호출하여 사용함.
3. API는 OS Sys. Call을 수행하는 wrapper 역할.
4. 사용자는 API를 디바이스 제어 함수로 인식하고 APP 설계.
6) SVC 핸들러 (SVC에 의한 system call)
1. HandlerSVC:
stmfd sp!, {r4, lr}
ldr r4, [lr, #-4]
bic r4, r4, #0xff000000
ldr r12, =SVC_Handler
ldr lr, [r12, r4, lsl #2]
blx lr
ldmfd sp!, {r4, pc}^

<4과. Interrupt Handler 설계>
1) Interrupt Controller의 필요성
1. ARM 코어에는 FIQ, IRQ 각각 1개씩만 존재함.
하지만 ARM 프로세서는 인터럽트 소스가 많기 때문에, 코어 외부에 interrupt controller를 두어서 인터럽트 개수를 확장한다.
2. 인터럽트 컨트롤러 역할:
여러 인터럽트 소스들의 허용여부 결정
우선순위 결정
소스별로 IRQ, FIQ 판단
 다른 exception과 달리 각 인터럽트 소스 별로 service routine이 필요하다.
2) ARM GIC (Generic Interrupt Controller)
1. Cortex-A는 인터럽트 중첩을 지원하지 않도록 설계되어있다.
3) IRQ
1. IRQ가 발생하면 IRQ 핸들러에 의하여 해당 인터럽트의 서비스 루틴(ISR)이 실행되어야 한다.
2. ICCIAR_CPUn에서 ACKINTID 10비트값(IRQ 번호) 추출하기
3. Vectoring 작업
4. 설계:
Handler IRQ:
sub lr, lr #4
stmfd sp!, {r0-r3, r12, lr}
ldr r1, =ICCIAR_CPU0
ldr r0, [r1]
ldr r1, =0x3ff
and r0, r0, r1
ldr r1, =ISR_Vector
ldr r0, [r1, r0, lsl #2]
blx r0
ldmfd sp!, {r0-r3, r12, pc}^
5. Tail Call IRQ 주의사항
IRQ 함수임을 컴파일러에 알려야 함.
Scratch Reg. 맘대로 쓰지 않고,
LR-4 주소로 복귀하고
Exception 탈출명령으로 복귀해야함.
4) Tail Call 방식 FIQ 핸들러
1. IRQ와 유사하나 FIQ 고유의 R8-R12 레지스터를 사용할 수 있게 된다.
2. 따라서 Scratch나 일반 레지스터 백업이 불필요하다.
3. FIQ Attribut를 사용하면 컴파일러는 최대한 R8-R12를 사용하여 코드를 번역한다.
<3부. Cortex-A9 Coprocessor 제어>
<1과. Cortex-A9 Coprocessor>
1) Cortex-A9 Coproc.
1. 코프로세서는 프로세서를 돕는 헬퍼 역할.
2. CP15:
MMU 설정 및 제어
Cache 설정 및 제어
C0~C15 16개의 레지스터 보유
2) 분기예측
1. S-Suffix를 사용한 산술명령운 분기예측 불가
 Exception 탈출로 판단함
2. 산술연산의 destination이 PC이나 제2피연산자가 상수인 경우, 분기예측 불가.
3. 리턴스택
함수 호출 시 복귀주소를 스택에 저장하고,
리턴 명령을 prefetch하면 복귀주소를 pop해서 그 주소의 명령부터 prefetch.
 pipline flushing 없이 계속 리턴 이후 명령 수행 가능.
3) ISB (Instruction Synchronous Barrier)
1. MMU 설정 등, 주소체계 변경 명령이 있는 경우, 그 다음 실행 명령에 영향이 있는 경우, 문제가 된다.
2. ISB는 pipeline flush를 해준다!
4) SIMD 연산 명령 (Single Instruction Multiple Data)
1. NEON Coprocessor:
SIMD를 확장한 Advanced SIMD 연산을 수행하는 코프로세서 장치.
<2과. MMU의 Translation 기능>
1) MMU(Memory Management Unit)의 기능
1. Virtual Addr  Physical Addr 변환
2. 메모리 보호
3. Cache 정책 설정
4. MPU(Memory Protection Unit)
MPU는 메모리보호와 Cache 정책수립만 수행.
2) MMU Translation
1. ARM v7은 전체 4GB VA 영역을 1MB(section)으로 분할, 4096 섹션으로 관리한다.
2. 원리:
VA, PA 영역은 1MB 단위 섹션의 번호로 4GB에 대하여 0~4095까지 존재.
VA 하위 20비트는 PA[19:0]에 그대로.
VA[31:20] 은 MMU에 의하여 PA에 변환된다.
예를 들어 VA[31:20]이 0x000 일 때 0x002로 변경하도록 되어있다면,
VA 0x00012345  PA 0x00212345 로 변환된다.
3. MMU-T/T (MMU Translation Table):
CPU가 제시한 VA를 PA로 변경하기 위한 참조표
3) TTBR Section Translation
 
1. TTBR: MMU가 T/T(Translation Table)을 참조하기 위해 T/T가 생성된 PA 메모리 위치를 설정하는 레지스터
(T/T 는 외부 메모리에 있다.)
KB 2^10: 0x0000_0400
 
16KB 2^14: 0x0000_4000
32KB 2^15: 0x0000_8000
64KB 2^16: 0x0001_0000
128KB 2^17: 0x0002_0000
256KB 2^18: 0x0004_0000
 
MB 2^20: 0x0010_0000
 
128MB 2^27: 0x0800_0000
256MB 2^28: 0x1000_0000
 
GB 2^30: 0x4000_0000
2. 1st Level Descriptor
T/T의 4096개 Entry 4B 값을 1st Level Descriptor라 부른다.
1MB 섹션 변환  18, 1, 0 비트가 각각 0, 1, 0 인 경우
<1MB align된 경우>
T/T[31:20]은 VA[31:20]과 교체될 값이고,
나머지 비트들은 보호, 캐시 정책 설정 정보이다.

4) TTBR 레지스터
1. MMU T/T는 4096개의 4B 요소 배열이므로 총 16KB의 메모리가 필요하다!
16KB == 2^14 == 0x0000_4000
2. T/T 크기는 16KB이며 16KB align 된 위치에 저장되어야 한다.
이 aligned된 주소 T/T가 생성된 메모리 위치를 알려주는 레지스터가 바로 TTBR (T/T Base Reg.)
TTBR에는 [31:14] 값만 설정하면 된다. 
3. 1MB 영역을 더 작게 분할하여 관리하는 경우 2nd Level T/T까지 필요하다.
5) 빈번한 APP 교체를 위한 TTBR0, TTBR1 활용
1. ARM v7은 APP 마다 메모리 낭비없이 T/T를 갖도록 2개의 TTBR을 제공함.
2. TTBR0는 다중의 APP들의 T/T 주소들을 지정하는 용도로 사용된다.
3. TTBR1은 Entry 내용이 고정적인 OS의 T/T의 주소를 지시하는 레지스터로 쓴다.
4. TTBCR 레지스터 (TTB Control Reg.)
N: APP T/T 크기 결정
016KB, 18KB, 24KB, 41KB, 5512B, 6 256B, 7128B
APP T/T는 그 크기만큼의 align된 메모리 주소에 위치할 수 있다.
5. TTBCR, TTBR0, TTBR1 선택 원리:
a. TTBCR 레지스터에 의하여 TTBR0의 주소 영역 크기가 결정된다. (N)
b. N값에 의하여 APP T/T Base 주소가 TTBR0[31:14-N]로 설정된다.
Ex) N=0: APP T/T 메모리 크기 16KB, 16KB align
   N=1: APP T/T 메모리 크기 8KB, 8KB align
c. MMU는 VA를 보고 TTBR0, TTBR1 중 어느 것을 참조할 지 결정한다. (N=0인 경우 무조건 TTBR0)
//N값에 따라 TTBR0, TTBR1 공간이 나뉘어진다.
6) 2nd Level MMU T/T
1. 1st Level T/T는 1MB 섹션 단위로 메모리를 관리하는 반면,
2nd Level T/T는 1st T/T Entry를 세분화하여 256개의 Page 관리 Entry를 갖는다.
 

7) T/T 주소 변환 정리
 
8) 멀티 프로세싱
1. MMU 안에 TLB cache에 이전 App의 T/T 정보가 남아있으면 멀티 프로세싱이 정상적으로 동작하지 않는 문제가 생긴다.
 TLB를 초기화시켜야 함.
2. Entry 주소 변경시 매번 TLB를 비활성화하는 방법:
멀티프로세싱 app이 늘어날수록 invalidate로 인한 비효율성
3. nG(Non-GlobalLocal)과 ASID 활용
nG=0 : Global, nG=1: Local
<TLB Miss>
a. nG=0 Global인 경우 ASID도 함께 TLB로 Load한다.
<요청한 VA 변환테이블이 TLB에 1개 이상 있을 경우 Hit, Miss 판단>
a. nG=1 Local인 경우에,
현재 ASID와 저장된 Entry의 ASID가 같으면 ‘HIT’,
현재 ASID와 저장된 Entry의 ASID가 다르면 ‘MISS’
b. nG=0 Global이면 무조건 ‘HIT’
4. “MISS”인 경우에 ASID를 TLB Entry의 ASID로 Load한다.
5. ASID 이용한 멀티프로세싱:
APP이 적재되는 위치마다 다른 ASID를 부여하여 Local Entry를 생성한다. (Entry의 ASID가 여러 개)
9) TLB (Translation Lookaside Buffer)
1. MMU T/T가 외부메모리에 있기 때문에, 느린 속도 개선을 위해 TLB를 설치함 (일종의 Cache 메모리)
2. 이미 TLB 안에 존재하는 Entry는 계속 TLB에 있는 Entry 정보를 참조하게된다.
<3과. MMU의 Protection 기능>
1) XN, AP Protection
1. XN(Execute Never): 해당 영역에는 코드(명령어)가 존재하지 않음을 뜻함.
2) 임베디드 시스템 Stack Overflow 관리
1. Stack Assert 기법
함수 호출 시마다 Stack Assert Macro로 스택 잔량 체크
2. Stack 위치 전략
스택 넘침 발생시 빨리 문제가 발생하도록 스택 위치를 결정하는 방식. MMU, MPU가 없는 프로세서에 유리.
3. Stack Monitoring 기법
타이머 인터럽트 사용하여 구현. 타이머 인터럽트 발생시 SP값을 인쇄하여 스택을 감시한다.
 스택이 적정한 크기로 배정되었는지 확인하는 방법.
4. Access Flag 기법
처음에 스택 전체에 특정값(예. 0xcccccccc)으로 채워둔다. 프로그램을 종료한 후 스택의 값을 dump하여 계속 0xcccccccc인 영역을 확인한다.
 스택이 적정한 크기로 배정되었는지 확인하는 방법.
5. MMU, MPU Guard 기법
Stack 위에 Access 금지 영역으로 Guard를 생성하여 Fault를 발생하도록 하는 방식.
3) MMU, MPU Guard 전략
1. MMU를 이용하여 스택위에 스택 가드를 설치한다.
 
Stack Guard 영역은 MMU에서 접근 불가능으로 설정한다.
따라서 스택이 넘치면 Fault(D-abort)가 발생함.
일반적으로 ARM 프로세서는 guard를 1MB 또는 4KB로 설치가 가능하다.
2. Guard 해제한 후 늘어난 스택도 넘치면 프로그램이 문제가 발생할 수 있다.
 TLB에 옛날 데이터가 들어가있기 때문.
 Guard 영역의 MMU 속성 변경 후 TLB를 invalidate시켜야한다.
4) Access Flag
1. 개념: 
Simplified Access Permission은 AP[2:0] 3비트로 설정한다.
a. AP[0]=1: AP[2:1]에 의한 Simplified AP모드
b. AFE(Access Flag Extension)으로 사용.
AFE는 Simplified AP 사용시 AP[0]을 0으로 설정한 영역에 해당하는 모드이다.
 AP[0]=0 인 영역이 Access되면 Abort가 발생함.
 Access Permission과 달리 Access Flag Fault는 Entry가 TLB에 로딩되지 않는다!
 따라서 Entry 내용을 수정하더라도 invalidate가 필요없음.
 복귀할 땐 AP[0]=1로 수정하면 간단하게 Simplifed AP가 된다.

<4과. MMU의 Cache Policy 관리>
1) Cache와 Write Buffer
1. Cache: CPU가 메모리를 읽으면 그 주소를 포함한 일정 크기의 데이터를 Cache에 적재.
2. Write Buffer: CPU는 느린 메모리 대신 고속 WB에 쓰기를 수행하고 WB는 나중에 메모리에 백업한다. 
지연이 생길 수 있다.
순서가 바뀔 수 있다.
2) Cache Line Size / Line Fill
1. Line Size: 메모리 데이터가 Cache에 적재될 때 한번에 적재되는 양. (Cache에 가져오는 단위.)
2. CPU는 Cache에서 Tag 정보를 찾고 Cache에 
Tag가 있는 경우  HIT
Tag가 없는 경우  MISS  메모리에서 Line 가져옴.
3) Cache의 종류
1. Fully Associative Cache:
Memory의 데이터가 Cache의 어떤 Line 이든지 적재될 수 있는 구조.
 Cache 성능은 높아지지만 한번에 모든 Tag를 비교해야 하기 때문에 H/W적으로 비싸다.
2. Direct Mapped Cache
Memory의 데이터가 Cache의 지정된 하나의 Line으로만 적재되는 구조.
 Line 선택 0~7번: 특정 line에 대해서만 비교하기 때문에 H/W적으로 싸다.
 Tag와 비교는 하나만 필요하다. 하지만 같은 주소에 계속 분기하면 캐시 효율이 저하된다. 비효율적.
3. Set Associative Cache
Cache를 “Set과 Way”로 분할한다. 현재 쓰이는 대부분의 Cache가 이 종류.
예를 들면, 128B를 Line 2개로 구성된 4개의 Set로 분할하면  4-Set, 2-Way 구조.
주소에 따라 해당 메모리 영역은 고정된 Set에 적재되지만 Way는 자유롭게 배정될 수 있다. Way가 많을수록 효율적이다.
 Set 선택 0~7번 (Indexing)
 Tag와 비교: 있으면 Hit, 없으면 Miss (Tagging)
4. L1, L2 Cache, Write Buffer의 line 크기는 동일하다.
4) Indexing, Tagging에 따른 Cache 종류:
1. VIVT(Virtual Indexing Virtual Tagging)
빠른 Hit판단, 하지만 멀티프로세싱에 비효율적. 거의 쓰이지 않는다.
2. VIPT(Virtual Indexing Physical Tagging)
PIPT보다 빠르지만 Read-Only Cache에만 쓸 수 있다.
3. PIVT(Physical Indexing Virtual Tagging)
이론적으로만 가능. 실제론 안 씀.
4. PIPT(Physical Indexing Physical Tagging)
VIVT Cache의 멀티프로세싱의 경우 Remap 데이터의 Invalidate가 필요함.  멀티프로세싱 Cache 효율이 저하됨
PIPT Cache는 멀티프로세싱에 유리.
5. Write Buffer의 문제점:
쓰기시간 지연 발생, 쓰기순서 변경 발생 가능.
5) Cache의 Replacement와 Data Backup
1. Cache 내용과 메모리 내용이 일치하지 않는 불일치 문제
 Cache가 FULL인 상태에서 적재되었던 0x100번지 내용이 변경된 경우, 0x300번지 데이터가 0x100번지 자리로 들어올 때,
 Invalidate하게되면 메모리는 계속 과거값을 저장하는 문제가 발생한다.
Read Incoherency: Cache에 적재된 내용이 메모리에서 변경된 경우
Write Incoherency: Cache에 적재된 내용이 CPU에 의하여 변경된 경우
2. 불일치 문제 해결방법
 WT(Write-Through): Cache가 갱신될 때마다 즉시 메모리에 갱신한다.
 WB(Write-Back): 데이터를 모았다가 Cache에서 Replacement될 때 메모리에 갱신한다. 더 효율적.
3. Write-Back
WB캐시에서 Replacement 때 무조건 메모리에 백업하면 비효율적이다.
따라서 Cache에 Drity Bit를 설치하여, 적재된 영역이 수정되면 Set시킨다.
 Cache는 나중에 메모리 영역이 Cache에서 제거될 때 Dirty Bit를 보고 백업을 결정한다.
 WB모드에서 메모리에 백업하는 시간이 소요되면 CPU 읽기 동작이 지연된다.
6) 캐시 정책
1. 이전 ARM 버전
NCNM, NCB, CNB, CB
2. v7 Cache 정책 설정
Normal: 순서, 시간 지켜지지 않음.
Device: 순서가 지켜지지만 시간 지연 발생 가능
Strongly-Ordered: 순서와 시간이 지켜짐
3. 메모리 Shareable 속성
T/T의 S비트: 메모리 타입과 3종류의 Sharable 속성 설정.
Non-Shareable: Single Processor에서만 사용, 다른 코어와 공유하지 않음.
Inner-Shareable: 여러 Processor들이 공유하는 영역
Outer-Shareable: 여러 코어뿐 아니라 외부 장치 또는 외부 프로세서와 공유하는 영역.
4. 디바이스의 WB 사용 시 순서 보장:
두 개의 디바이스는 shareable 속성이 같은 경우 순서 보장함.
5. L1, L2 Cache 정책을 다르게 설정하려면 TEX[2]=1.
6. TRE 기능
캐시 속성을 자주 변경할 경우, 28번 비트를 1로 하면 TRE모드가 선택되고, 여기서 8개 종류의 캐시 속성 번호를 정할 수 있다. 6개 비트를 하나하나 바꾸지 않아도 되서 효과적이다.
7. NMRR, PRRR
NMRR: L1, L2 Cache 속성 설정
PRRR: 메모리 타입 설정
8. DSB, DMB 명령
 Write Buffer Flush 발생
7) External Abort Fault
1. Imprecise Fault (문제주소 확인 불가)
a. Write (store)하는 경우
b. Write Buffer가 켜진 경우
2. MMU가 접근 가능한데 메모리 맵에는 존재하지 않는 메모리 영역이면 버스 컨트롤러가 External Abort Fault!
3. 제조사의 SoC설계에 따라 발생시키는 기능이 다르다.
<5과. Cache Control>
1) Cache Control
1. I-Cache Control:
Invalidate: cache 전체 혹은 해당 entry를 cache에서 삭제.
2. D-Cache Control:
Invalidate: cache 전체 혹은 해당 entry를 cache에서 삭제.
Clean: Dirty Bit가 Set된 line을 메모리에 업데이트. (Dirty Bit은 Cache에 저장된 데이터가 값이 변경되었는지 check)
3. C7: L1 Cache Operation 명령을 사용해 Cache 제어.
Ex) MCR p15, 0, Rx, C7, C5, 0 //Invalidate all I-Cache
2) PoU, PoC 개념
1. PoU(Point of Unification):
Multi Core들끼리 데이터가 일치되는 조작.
Core들 L1은 각자, L2는 공유하는 경우, PoU는 L2 Cache까지 일치되는 시점.
2. PoC(Point of Coherence):
외부 메모리까지 데이터가 일치되는 동작
L1, L2 Cache 모두에 동작이 발생.
3) MVA & SET/WAY Format
1. MVA Format: 주소(VA)를 저장하여 Cache 제어를 수행
2. SET/WAY Format: Set과 Way, Cache를 지정하여 Cache 제어를 수행. 주로 Cache 초기화할 경우에 사용한다.
4) ADC 액세스 프로그램 동작 예시
1. ADC는 Memory Mapped I/O 영역.
2. 이 영역 접근은 volatile 선언 필요!
3. Cache도 쓰면 안된다. “읽기 불일치 문제” 발생.
 volatile 선언 + Cache 사용하지 않기
4. D-Cache 읽기 불일치 문제:
Cache로 로딩된 메모리 영역이 변경되어 Cache 값이 예전 값을 갖게 되는 상황.
 Memory Mapped I/O: H/W에 의한 변경
 DMA로 메모리에 직접 기록: DMA에 의한 변경
 MMU Remap: 현재 Fill된 데이터들이 이전 PA 데이터 보유
5. DMA로 읽어오는 영역 불일치 문제 해결방법:
a. 해당 영역을 NCNB, NCB 처리
b. DMA 영역을 읽어오기 전에 해당 메모리 영역 Invalidate.
5) D-Cache 쓰기 불일치 문제 발생 경우
1. Write Incoherence: Cache에 적재된 영역을 CPU가 변경하여 메모리와 일치하지 않는 현상.
2. 발생되는 경우:
a. Memory Mapped I/O 영역: H/W는 바뀐 내용 적용못함
b. DMA 기반으로 메모리를 읽어가는 경우
3. DMA로 읽어가는 영역의 경우 문제 해결 방법:
a. 해당 영역을 NCNB, NCB 처리. (비효율적)
b. DMA 영역: 쓰고 난 후에 해당 메모리 영역 Clean
c. WT Cache로 설정하여 쓰기 불일치가 발생하지 않도록 설정.
